<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[组件化方案的第三种选择]]></title>
    <url>%2Fthe-third-option-of-componentization-scheme.html</url>
    <content type="text"><![CDATA[背景：市面上已开源的或者已发布的组件化方案，多数都是开发阶段单一工程结构，切换module模式。本质上依然没有达到代码完全隔离的目的，开发与整合测试中的一些痛点还是没有彻底解决 我们的方案：代码完全隔离，互相只能依赖，不可编辑，各模块可以单独运行，也可组合依赖 本文内容为亲自实践并验证之后整理，理解了思路，具体实施方案其实可以有多种，最主要的是自己觉得合适的。 先看看常见的方案 第一种方案-单一项目结构该架构模式比较大众化，很多组件化demo 都是这种结构，比如得到 核心思想：所有业务组件及common组件以module形式存在于一个项目内 优点： 项目没有冗余，便于管理 缺点：没有达到组件完全隔离效果，组件插拔使用仍需新建或导入项目 代码结构 解读： app:项目module，无具体业务，不包含具体页面，只负责编译依赖组件、集成打包 module_main: main组件，定义启动页与主页 module_a:业务组件 moduel_baidulocation：功能组件 module_common: 基础公共组件 各组件为独立工程架构后面说明,基本配置及思想不变 组件文件结构 ： 由于组件以Module形式存在于项目内 因此只保留Module目录文件，其他工程文件统一由主体工程提供 主体项目配置setting.gradle配置include所有组件module 如： 1234include ':app', ':module_main', ':module_a', ':module_common' app Module配置 build.gradle配置始终为com.android.application 编译依赖： 依赖底层公共组件 集成模式条件下，编译全部组件 如： 123456if(!isDebug.toBoolean())&#123; implementation project(':module_main') implementation project(':module_a') &#125; implementation project(':module_common') 调试运行修改gradle.properties isDebug=true，独立运行调试 isDebug=false，编译运行整个project 组件单独运行与整个project运行切换： 注意:组件间资源重复会在最终打包时发生冲突，即使通过编译成功打包，在运行时也会出现资源问题。建议增加模块前缀加以区分避免 第二种方案-多项目结构 核心思想：每个组件都做为一个独立项目存在 ,负责组合打包各组件的主项目只有一个 优点： 除公共组件或功能组件存在依赖关系外，组件间互相隔离 缺点：项目冗余 代码结构 解读： ComponentApp为主工程，最终负责打包组件，无具体业务，只配置程序相关内容 ComponentMain为主组件，配置启动页与首页 ComponentA为业务组件 ComponentBaidu 为功能组件 ComponentCommon 为公共组件 所有组件依赖公共组件 继承BaseApplication, 开发时将全局Application转型为BaseApplication,避免打包时 Application失效 文件结构 具体路径按需存放 各组件均为独立项目 主体项目配置setting.gradle配置以依赖项目与主体项目在同级目录为例： 引入依赖组件，使用project (&#39;:项目&#39;).projectDir = new File(&#39;../项目&#39;)定义路径 12345678910111213include &apos;:app&apos;include &apos;:ComponentMain&apos;project (&apos;:ComponentMain&apos;).projectDir = new File(&apos;../ComponentMain&apos;)include &apos;:ComponentMain:main&apos;include &apos;:ComponentA&apos;project (&apos;:ComponentA&apos;).projectDir = new File(&apos;../ComponentA&apos;)include &apos;:ComponentA:moduleA&apos;include &apos;:ComponentCommon&apos;project (&apos;:ComponentCommon&apos;).projectDir = new File(&apos;../ComponentCommon&apos;)include &apos;:ComponentCommon:common&apos; build.gradle配置编译各组件内指定Module 123456if(!isDebug.toBoolean())&#123; implementation project(&apos;:ComponentMain:main&apos;) implementation project(&apos;:ComponentA:moduleA&apos;) &#125; implementation project(&apos;:ComponentCommon:common&apos;) 调试运行修改 gradle.properties 内isDebug app Module由于没有默认Activity，因此无法运行 注意:有依赖关系的组件 配置需一致，否则编译失败 第三种方案-彻底组件化 核心思想：最大化隔离，最少代码侵入，最少修改感知 方案 抛弃开发阶段与发布阶段gradle配置的Library与Application切换 每一个组件都是一个独立的工程，组件仍是Library，与开发阶段使用的demo分离。整体工程一并发布。最终只能有一个Application 组件互相隔离，互相不可编辑，只能使用。Library 发布为jar或aar文件，远程依赖引入 清单文件配置（所有我们知道的配置）都可以写进Library，最后打包时会自动合并，无需人为干扰。 gradle扩展配置，manifest 经常变化的配置写进gradle配置文件，减少配置侵入 业务组件之间依赖后通过路由或其他方式交互（自行选择），功能组件可直接依赖使用 涉及知识点仓库以maven为例，以下内容，搜索引擎都可解答 Library Maven 配置 搭建本地Maven仓库 Manifest动态配置替换 Gradle插件开发 组件交互：Arouter，ActivityRouter 实践理解以上所有点，一步一个脚印 组件交互方案 阿里ARouter 框架 ActivityRouter 仓库发布方式分类 jcenter maven 本地私有仓库 私有仓库搭建拥抱 Android Studio 之四：Maven 仓库使用与私有仓库搭建在Android Studio中发布Library到jCenter公共仓库自建私有Maven 仓库]]></content>
      <categories>
        <category>android</category>
        <category>组件化</category>
      </categories>
      <tags>
        <tag>实战</tag>
        <tag>总结</tag>
        <tag>组件化</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义Gradle插件，之扩展Gradle配置]]></title>
    <url>%2Fgradle-custom-configuration.html</url>
    <content type="text"><![CDATA[把一些经常变化的配置放在Gradle内，达到变化时只修改Gradle文件，不去动其他文件，减少出错的概率目的参考ShareSDK 的项目配置思路，实现我们自己的Gradle扩展配置 注：暂不涉及Gradle配置对象直间的值传递方案 结构 实现方案 插件定义：`plugin-custom.properties 文件： 1implementation-class = com.company.plugin.CustomPlugin` 说明： 文件名.properties 即插件id，也是我们后面要引入时使用的id 类似于：apply plugin&#39;com.android.applicaiton&#39; 文件配置内容：指定具体插件实现类 com.company.plugin.CustomPlugin 自定义插件实现类：CustomPlugin.groovy 1234567891011public class CustomPlugin implements Plugin&lt;Project&gt;&#123; @Override void apply(Project project) &#123; //扩展属性定义 project.extensions.create('pluginSupport', TinkerConfigSupport) // 应用 其他插件,以Tinker为例，等同于build.gradle应用 project.apply plugin: 'com.tencent.tinker.patch' &#125;&#125; 扩展属性定义，由create指定，String类型pluginSupport 1project.extensions.create('pluginSupport', PluginConfig) 注意：子类属性必需初始化，否则异常 子属性定义及构造方法初始化属性 PluginConfig.groovy 12345678910public class PluginConfig &#123; boolean booleanValue String stringValue PluginConfig() &#123; booleanValue = false stringValue = "" &#125; 插件build.gradle配置1234567891011121314151617181920212223//语法插件apply plugin: 'groovy'dependencies &#123; //语法支持 compile gradleApi() compile localGroovy() //插件支持 compile 'com.google.gradle:osdetector-gradle-plugin:1.2.1' compile 'com.android.tools.build:gradle:2.1.0' &#125;sourceSets &#123; main &#123; groovy &#123; srcDir 'src/main/groovy' &#125; resources &#123; srcDir 'src/main/resources' &#125; &#125;&#125; 两个重要方法12project.afterEvaluate 解析gradle配置文件之后执行project.beforeEvaluate 解析之前执行 发布注：发布目录根据需要修改 插件buidl.gradle配置123456789101112131415//发布插件apply plugin: 'maven'uploadArchives &#123; repositories &#123; mavenDeployer &#123; //设置插件的GAV参数 pom.groupId = 'groupId' pom.artifactId = 'artifactId' pom.version = 1.0//指定版本号 //文件发布到本地目录 repository(url: uri('../plugin')) &#125; &#125;&#125; 配置完成后执行（Terminal也可）：Gradle-&gt;build-&gt;uploadArchives 使用需要引入的modulebuild.gradle文件，添加如下代码即可完成引入： 123456buildscript&#123; dependencies&#123; classpath 'groupId:artifactId:1.0' &#125;&#125;apply plugin: 'plugin-custom' 扩展属性配置赋值，build.gradle文件：1234pluginSupport&#123; booleanValue = true; stringValue = "自定义插件扩展属性值"&#125; 参考]]></content>
      <categories>
        <category>原创</category>
        <category>Android</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>配置</tag>
        <tag>扩展</tag>
        <tag>自定义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小游戏屏幕适配]]></title>
    <url>%2Fminigame-screenadaptation.html</url>
    <content type="text"><![CDATA[很久没有发文了，最近一直在研究微信小游戏，屏幕适配问题真的是哪里都存在。无奈论坛资料及可行的解决方案还是太少，还是得靠自己。且来看一看在微信上如何达到适配多样化屏幕 奔着解决方案来的可直达解决方案 后续将根据实际遇到的其他问题，继续发出真实可行的解决方案 工具LayaAir 引擎TypeScripte 语言 需要关注的点 主要集中在背景图及边框附近的UI元素位置重设 缩放后安全区域（不会被裁切）内的UI 响应位置是否会被改变 与屏幕有关的一些基础内容屏幕方向不受屏幕方向影响，不会改变物理屏幕方向 1234//竖屏 Laya.stage.screenMode = Laya.Stage.SCREEN_VERTICAL//横屏Laya.stage.screenMode = Laya.Stage.SCREEN_HORIZONTAL 缩放模式 Laya.init之后，舞台宽高无法再更改 Laya.stage.scaleMode 12345678Laya.Stage.SCALE_NOSCALE "noscale"Laya.Stage.SCALE_FULL "full"Laya.Stage.SCALE_EXACTFIT "exactfit"Laya.Stage.SCALE_SHOWALL "showall"Laya.Stage.SCALE_NOBORDER "noborder"Laya.Stage.SCALE_FIXED_WIDTH "fixedwidth"Laya.Stage.SCALE_FIXED_HEIGHT "fixedheight"Laya.Stage.SCALE_FIXED_AUTO "fixedauto" 缩放详解 总结noscale: 不缩放不变形，1:1原始比例，左上角对齐，内容大于屏幕被裁切，小于屏幕出现黑边 full：不缩放，原始比例，超出屏幕部分被裁切 exactfit：非等比缩放，填满屏幕，设计宽高与设备不等时会变形 showall: 等比缩放，按屏幕宽高与设计比例最小比率等比缩放，可能会黑边 noborder：等比缩放，按屏幕宽高与设计宽高最大比例缩放，超过屏幕部分被裁切 fixedheight:按屏幕宽高等比缩放，高度不变，宽度适配（设计高度*屏幕宽高比），宽度超出会裁切 fixedwidth: 按屏幕宽高等比缩放，宽度不变，高度适配 (设计宽度*屏幕高宽比)，高度不够会黑边 fixedauto:自动计算选择fixedwidth或fixedheight 不裁剪方案：noscale, exactfit，showall 不缩放：noscale, full 等比缩放会裁剪：noborder,fixedheight 其他引擎的参考方案白鹭的适配方案:noscale,exactfit,showall,noborder cocos的策略: 适配高度或宽度或根据宽高比自动选择，裁剪背景图，避免黑边或空白，设置子UI元素自动对齐到可见区域 Laya缩放适配验证 基于微信开发者工具自带的模拟器实验 设计宽高与屏幕一致时各模式无影响 iphonex:fixedwidth，宽度不变，高度适配，黑边 fiexdheight，高度不变，宽度适配，被裁剪 full: 左上角，未铺满屏幕，与小米note2表现一致 其他模式差距细微 6到 iphone7Pfull: 左上角，未铺满屏幕 其他模式差距细微 nexus5到nexus6与6到7p表现一致 两种可行的解决方案两套图适配iphonex 大分辨率与5s 小分辨率对比图见《游戏截图》文档 按物理分辨率取比，以16：9为基础 12//比例大于16:9的，标记为大分辨率this.isLargeScreen= Math.floor(height/width)&gt;Math.floor(16/9) 背景资源分别获取 123 if(this.isLargeScreen) bg.skin = "大图" else bg.skin = "小图"; 不缩放(默认值，可不写) 1Laya.stage.scaleMode = Laya.Stage.SCALE_NOSCALE 舞台尺寸设置为固定物理尺寸，保证各16:9 设备等比缩放，不会出现黑边 12345if (this.isLargeScreen) &#123; Laya.init(1125, 2436, Laya.WebGL); &#125; else &#123; Laya.init(640, 1136, Laya.WebGL); &#125; 原因：现有缩放模式不支持两边裁剪，至多为一边裁剪 一套图适配示例：天才削熊猫 思路：高度不变，宽度适配，水平居中，两边裁剪，元素相对布局，设计时设置安全区域 实现：一套背景图，1480x1920，水平居中：centerx = 0，y = 0，启用相对父类布局layoutEnable = true 屏幕宽高：1080x1920 代码或UI 元素：启用相对父类布局，设置left,right top ,bottom，layoutEnable = true 缩放模式：fixedHeight 代码示例 以1080x1920(具体看需求)尺寸图为标准、设计尺寸，路径以res为例 12345678910111213141516171819//舞台初始化Laya.init(1080, 1920);//缩放模式Laya.stage.scaleMode = Laya.Stage.SCALE_FIXED_HEIGHT;//背景添加var imageBg:Laya.Image = new Laya.Image(); imageBg.skin = "res/bg_main.png";imageBg.centerX = 0;imageBg.layoutEnabled = true;imageBg.y = 0;Laya.stage.addChild(imageBg);//UI元素添加，以添加到舞台为例 var btn: Laya.Button = new Laya.Button();btn.skin = "res/btn.png";btn.layoutEnabled = true;btn.left = 165;btn.bottom = 50;btn.stateNum = 1;Laya.stage.addChild(btn);]]></content>
      <categories>
        <category>原创</category>
        <category>游戏开发</category>
        <category>微信小游戏</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>微信</tag>
        <tag>小游戏</tag>
        <tag>屏幕适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓常见动画合集]]></title>
    <url>%2Fandroid-animation-collection.html</url>
    <content type="text"><![CDATA[注：除特殊说明停止维护外，列出的库仍在维护中。长时间未维护的依赖库，提供了jar文件的，可直接依赖jar 文件 谷歌提供属性动画3.0以上官方api自带 Animators: 123ValueAnimatorObjectAnimatorAnimatorSet Evaluators: 1234IntEvaluatorFloatEvaluatorArgbEvaluatorTypeEvaluator Interpolators: 12345678910AccelerateDecelerateInterpolator AccelerateInterpolator AnticipateInterpolator AnticipateOvershootInterpolator BounceInterpolator CycleInterpolator DecelerateInterpolator LinearInterpolator OvershootInterpolator TimeInterpolator 监听： 12Animator.AnimatorListenerValueAnimator.AnimatorUpdateListener xml 动画类对应标签ValueAnimator -&gt; &lt;animator&gt; ObjectAnimator - &lt;objectAnimator&gt; AnimatorSet - &lt;set&gt; 代码 使用 ValueAnimator 方法：ofInt(), ofFloat(),ofObject() 123ValueAnimator animation = ValueAnimator.ofFloat(0f, 100f);animation.setDuration(1000);animation.start(); 123ValueAnimator animation = ValueAnimator.ofObject(new MyTypeEvaluator(), startPropertyValue, endPropertyValue);animation.setDuration(1000);animation.start(); 使用 ValueAnimator 对象的值 设置AnimatorUpdateListener 监听 12345678910animation.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator updatedAnimation) &#123; // You can use the animated value in a property that uses the // same type as the animation. In this case, you can use the // float value in the translationX property. float animatedValue = (float)updatedAnimation.getAnimatedValue(); textView.setTranslationX(animatedValue); &#125;&#125;); ObjectAnimator 123ObjectAnimator animation = ObjectAnimator.ofFloat(textView, "translationX", 100f);animation.setDuration(1000);animation.start(); 1ObjectAnimator.ofFloat(targetObject, "propName", 1f) AnimatorSet 1234567891011AnimatorSet bouncer = new AnimatorSet();bouncer.play(bounceAnim).before(squashAnim1);bouncer.play(squashAnim1).with(squashAnim2);bouncer.play(squashAnim1).with(stretchAnim1);bouncer.play(squashAnim1).with(stretchAnim2);bouncer.play(bounceBackAnim).after(stretchAnim2);ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, "alpha", 1f, 0f);fadeAnim.setDuration(250);AnimatorSet animatorSet = new AnimatorSet();animatorSet.play(bouncer).before(fadeAnim);animatorSet.start(); 监听 API： Animator.AnimatorListener 1234onAnimationStart()onAnimationEnd()onAnimationRepeat()onAnimationCancel() ValueAnimator.AnimatorUpdateListener 12onAnimationUpdate()getAnimatedValue() 示例： 123456ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, "alpha", 1f, 0f);fadeAnim.setDuration(250);fadeAnim.addListener(new AnimatorListenerAdapter() &#123;public void onAnimationEnd(Animator animation) &#123; balls.remove(((ObjectAnimator)animation).getTarget());&#125; ViewGroupAPI: void setAnimator(int transitionType, Animator animator) transitionType: 1234LayoutTransition.APPEARING LayoutTransition.CHANGE_APPEARINGLayoutTransition.DISAPPEARING LayoutTransition.CHANGE_DISAPPEARING 需Layout布局属性支持：android:animateLayoutchanges= true View状态动画1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!-- the pressed state; increase x and y size to 150% --&gt; &lt;item android:state_pressed="true"&gt; &lt;set&gt; &lt;objectAnimator android:propertyName="scaleX" android:duration="@android:integer/config_shortAnimTime" android:valueTo="1.5" android:valueType="floatType"/&gt; &lt;objectAnimator android:propertyName="scaleY" android:duration="@android:integer/config_shortAnimTime" android:valueTo="1.5" android:valueType="floatType"/&gt; &lt;/set&gt; &lt;/item&gt; &lt;!-- the default, non-pressed state; set x and y size to 100% --&gt; &lt;item android:state_pressed="false"&gt; &lt;set&gt; &lt;objectAnimator android:propertyName="scaleX" android:duration="@android:integer/config_shortAnimTime" android:valueTo="1" android:valueType="floatType"/&gt; &lt;objectAnimator android:propertyName="scaleY" android:duration="@android:integer/config_shortAnimTime" android:valueTo="1" android:valueType="floatType"/&gt; &lt;/set&gt; &lt;/item&gt;&lt;/selector&gt; 布局引用： android:stateListAnimator 12&lt;Button android:stateListAnimator=&quot;@xml/animate_scale&quot;... /&gt; ViewAPI: 123456translationX,translationY//相对父Viewrotation, rotationX, rotationY//相对支点 2D: rotation ,3D旋转scaleX scaleY //相对支点 2D缩放pivotX pivotY //控制旋转，缩放支点，默认值为中间x y //相对父View 最终位置alpha//View透明度 默认值1，0为完全透明 示例: 创建动画，指定View属性即可 1ObjectAnimator.ofFloat(myView, "rotation", 0f, 360f); Interpolator AccelerateDecelerateInterpolator 1234public float getInterpolation(float input) &#123; return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;&#125; LinearInterpolator 1234public float getInterpolation(float input) &#123; return input;&#125; ViewPropertyAnimator 组合 ObjectAnimator 123456ObjectAnimator animX = ObjectAnimator.ofFloat(myView, "x", 50f);ObjectAnimator animY = ObjectAnimator.ofFloat(myView, "y", 100f);AnimatorSet animSetXY = new AnimatorSet();animSetXY.playTogether(animX, animY);animSetXY.start(); 单个ObjectAnimator 1234PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat("x", 50f);PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat("y", 100f);ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvyY).start(); ViewPropertyAnimator 12myView.animate().x(50f).y(100f); xml定义 定义 AnimatorSet 123456789101112131415161718&lt;set android:ordering="sequentially"&gt; &lt;set&gt; &lt;objectAnimator android:propertyName="x" android:duration="500" android:valueTo="400" android:valueType="intType"/&gt; &lt;objectAnimator android:propertyName="y" android:duration="500" android:valueTo="300" android:valueType="intType"/&gt; &lt;/set&gt; &lt;objectAnimator android:propertyName="alpha" android:duration="500" android:valueTo="1f"/&gt;&lt;/set&gt; 引入AnimatorSet 1234AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext, R.anim.property_animator);set.setTarget(myObject);set.start(); 定义 Animator 12345&lt;animator xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000" android:valueType="floatType" android:valueFrom="0f" android:valueTo="-100f" /&gt; 引入Animator 1234567891011ValueAnimator xmlAnimator = (ValueAnimator) AnimatorInflater.loadAnimator(this, R.animator.animator);xmlAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator updatedAnimation) &#123; float animatedValue = (float)updatedAnimation.getAnimatedValue(); textView.setTranslationX(animatedValue); &#125;&#125;);xmlAnimator.start(); 物理动画官方支持库support-dynamic-animation gradle依赖1compile 'com.android.support:support-dynamic-animation:27.1.0' 版本： 注：要求sdk最低版本 为16，编译版本27，功能可用情况下，可适当降低support版本及编译版本 api官方地址 接口 12DynamicAnimation.OnAnimationEndListenerDynamicAnimation.OnAnimationUpdateListener 类 1234567DynamicAnimation&lt;T extends DynamicAnimation&lt;T&gt;&gt;DynamicAnimation.ViewPropertyFlingAnimationFloatPropertyCompat&lt;T&gt;FloatValueHolderSpringAnimationSpringForce 使用开源库属性动画 3.0以下NineOldAndroids 注：已停止更新 gradle依赖1compile 'com.nineoldandroids:library:2.4.0' jar 依赖将jar包：nineoldandroids-2.4.0.jar 置于libs目录 使用与官方属性动画api使用方式一致 加载动画ZLoading 源码支持api 15及以上，14及以下需手动变更，功能无影响 gradle依赖1compile 'com.zyao89:zloading:1.0.11' 使用 xml 12345&lt;com.zyao89.view.zloading.ZLoadingView android:layout_width="wrap_content" android:layout_height="wrap_content" app:z_type="CircleBuilder" app:z_color="@color/colorAccent"/&gt; 代码：ZLoadingView 123ZLoadingView zLoadingView = (ZLoadingView) findViewById(R.id.loadingView_1);zLoadingView.setLoadingBuilder(Z_TYPE.CIRCLE);//设置类型zLoadingView.setColorFilter(Color.WHITE);//设置颜色 Dialog：ZLoadingDialog 1234567ZLoadingDialog dialog = new ZLoadingDialog(MainActivity.this);dialog.setLoadingBuilder(type)//设置类型 .setLoadingColor(Color.BLACK)//颜色 .setHintText("Loading...") .setHintTextSize(16) // 设置字体大小 dp .setHintTextColor(Color.GRAY) // 设置字体颜色 .show(); 支持的类型12345678910111213141516171819类名 枚举类型 名称CircleBuilder CIRCLE 圆ClockBuilder CIRCLE_CLOCK 计时器StarBuilder STAR_LOADING 跳舞的星星LeafBuilder LEAF_ROTATE 旋转的叶子DoubleCircleBuilder DOUBLE_CIRCLE 画两个圈圈PacManBuilder PAC_MAN PacManElasticBallBuilder ELASTIC_BALL 颤抖吧！球球InfectionBallBuilder INFECTION_BALL 感染体IntertwineBuilder INTERTWINE 交织TextBuilder TEXT 文字SearchPathBuilder SEARCH_PATH 搜索等待RotateCircleBuilder ROTATE_CIRCLE 多圆旋转SingleCircleBuilder SINGLE_CIRCLE 单圆简单动画SnakeCircleBuilder SNAKE_CIRCLE 引蛇出洞StairsPathBuilder STAIRS_PATH 舞动阶梯MusicPathBuilder MUSIC_PATH 跳动音符StairsRectBuilder STAIRS_RECT 递增方块ChartRectBuilder CHART_RECT 跳动的柱状图 效果 gifairbnb-lottie-android支持动画json文件解析,canvas绘制动画 gradle依赖 使用latest.integration依赖最新版本 1compile 'com.airbnb.android:lottie:latest.integration' 使用 xml 1234567&lt;com.airbnb.lottie.LottieAnimationView android:id="@+id/animation_view" android:layout_width="wrap_content" android:layout_height="wrap_content" app:lottie_fileName="hello-world.json" app:lottie_loop="true" app:lottie_autoPlay="true" /&gt; 代码 1234LottieAnimationView animationView = (LottieAnimationView) findViewById(R.id.animation_view); animationView.setAnimation("hello-world.json"); animationView.loop(true); animationView.playAnimation(); android-gif-drawable 源码编译需ndk支持 Android studio 插件： 支持gif格式,最低支持api版本：14 gradle依赖1compile 'pl.droidsonroids.gif:android-gif-drawable:1.2.12' 如果依赖失败，在项目 gradle内配置： 12345678910buildscript &#123; repositories &#123; mavenCentral() &#125;&#125;allprojects &#123; repositories &#123; mavenCentral() &#125;&#125; 使用示例 xml ImageView 123456&lt;pl.droidsonroids.gif.GifImageView android:layout_width="match_parent" android:layout_height="match_parent" android:src="@drawable/src_anim" android:background="@drawable/bg_anim" /&gt; TextView 1234567&lt;pl.droidsonroids.gif.GifTextView android:layout_width="match_parent" android:layout_height="match_parent" android:drawableTop="@drawable/left_anim" android:drawableStart="@drawable/left_anim" android:background="@drawable/bg_anim" /&gt; 代码 GifImageViwe, GifImageButton ,GifTextView 支持setImageResource(int resId)，setBackgroundResource(int resId)动态设置gif图片资源 GifDrawable: 12345678910111213141516171819202122232425262728293031323334353637//asset fileGifDrawable gifFromAssets = new GifDrawable( getAssets(), "anim.gif" ); //resource (drawable or raw)GifDrawable gifFromResource = new GifDrawable( getResources(), R.drawable.anim ); //UriContentResolver contentResolver = ... //can be null for file:// UrisGifDrawable gifFromUri = new GifDrawable( contentResolver, gifUri );//byte arraybyte[] rawGifBytes = ...GifDrawable gifFromBytes = new GifDrawable( rawGifBytes ); //FileDescriptorFileDescriptor fd = new RandomAccessFile( "/path/anim.gif", "r" ).getFD();GifDrawable gifFromFd = new GifDrawable( fd ); //file pathGifDrawable gifFromPath = new GifDrawable( "/path/anim.gif" ); //fileFile gifFile = new File(getFilesDir(),"anim.gif");GifDrawable gifFromFile = new GifDrawable(gifFile); //AssetFileDescriptorAssetFileDescriptor afd = getAssets().openFd( "anim.gif" );GifDrawable gifFromAfd = new GifDrawable( afd ); //InputStream (it must support marking)InputStream sourceIs = ...BufferedInputStream bis = new BufferedInputStream( sourceIs, GIF_LENGTH );GifDrawable gifFromStream = new GifDrawable( bis ); //direct ByteBufferByteBuffer rawGifBytes = ...GifDrawable gifFromBytes = new GifDrawable( rawGifBytes ); gif控制MediaController 12345678910111213141516@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); GifImageButton gib = new GifImageButton(this); setContentView(gib); gib.setImageResource(R.drawable.sample); final MediaController mc = new MediaController(this); mc.setMediaPlayer((GifDrawable) gib.getDrawable()); mc.setAnchorView(gib); gib.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; mc.show(); &#125; &#125;);&#125; 1234567getLoopCount()//循环次数getNumberOfFrames()//返回帧数，至少1帧getComment()// 注释文本getFrameByteCount()//可用于存储单帧像素最小字节数getAllocationByteCount()//GifDrawable用于存储像素的已分配内存的大小(以字节为单位)getInputSourceByteCount()//后备输入数据的长度(字节)toString()//调试用的，图像大小和帧数的信息 回调MultiCallback 支持的功能： recycle() 释放内存 isRecycled() getError() 返回错误详细内容 123456789MultiCallback multiCallback = new MultiCallback();imageView.setImageDrawable(gifDrawable);multiCallback.addView(imageView);anotherImageView.setImageDrawable(gifDrawable);multiCallback.addView(anotherImageView);gifDrawable.setCallback(multiCallback); 物理-弹簧动画 已停止维护，依赖可用 FaceBook-Rebound Gradle依赖1compile 'com.facebook.rebound:rebound:0.3.8' jar 依赖将jar包：rebound-0.3.8.jar置于libs目录 API类： SpringSystem 方法：create 监听：SpringListener ，SimpleSpringListener 回调方法：onSpringUpdateonSpringAtRestonSpringActivateonSpringEndStateChange 官方使用示例123456789101112131415161718192021SpringSystem springSystem = SpringSystem.create(); // Add a spring to the system. Spring spring = springSystem.createSpring(); // Add a listener to observe the motion of the spring. spring.addListener(new SimpleSpringListener() &#123; @Override public void onSpringUpdate(Spring spring) &#123; // You can observe the updates in the spring // state by asking its current value in onSpringUpdate. float value = (float) spring.getCurrentValue(); float scale = 1f - (value * 0.5f); targetView.setScaleX(scale); targetView.setScaleY(scale); &#125; &#125;); // Set the spring in motion; moving from 0 to 1 spring.setEndValue(1); 属性-动画View Shaker AndroidViewAnimations 内置多种动画，支持链式调用 最近更新日期：2017/6 gradle依赖12compile 'com.daimajia.easing:library:2.0@aar'compile 'com.daimajia.androidanimations:library:2.3@aar' API枚举类型 Techniques，指定具体类型即可 with palyOn(View target) 使用示例1234YoYo.with(Techniques.Tada) .duration(700) .repeat(5) .playOn(targetView); 1YoYo.with(Techniques.Shake).playOn(targetView); 效果]]></content>
      <categories>
        <category>原创</category>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>动画</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manifest配置动态替换]]></title>
    <url>%2Fmanifest-configuration-dynamic-replacement.html</url>
    <content type="text"><![CDATA[该方案是根据极光推送的官方配置方案而来,后续将推出gradle自定义插件的方式完成配置替换 目的减少配置侵入、关键信息暴露 便于可变配置信息引入及替换 封装动态配置定义在Library内，由app完成替换 注意： 当Library 的清单文件定义了替换key,gradle没有填写，在编译期会出现如下日志，只要app内 填写正确，运行不受影响 日志详细信息: 12Error: Attribute meta-data#QQ_APPID@value at manifestMerger8142313556881373986.xml requires a placeholder substitution but no value for &lt;QQ_APPID&gt; is provided Library 如果与app同时配置，将会冲突导致都无效，及时Llbrary配置值为空，app已配置的也会被替换掉 Manifest 定义 常规定义：”${定义的内容}” 会出现数字的，读取时不会被读取为String类型，需要通过反斜杠转义 ：”\ ${定义的内容}” 想动态替换的内容都可定义，并由gradle 完成替换 如： 123456789101112131415161718192021&lt;!--动态配置meta-data的可变内容--&gt;&lt;meta-data android:name="QQ_APPKEY" android:value="\ $&#123;QQ_APPID&#125;"/&gt;//转义数字为String&lt;meta-data android:name="QQ_SECRET" android:value="$&#123;QQ_SECRET&#125;"/&gt;&lt;!--动态配置Activity的过滤器可变内容--&gt; &lt;activity&gt; &lt;intent-filter&gt; &lt;data android:scheme="tencent$&#123;QQ_APPID&#125;"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;!--动态配置Receiver的过滤器可变内容--&gt; &lt;receiver&gt; &lt;intent-filter&gt; &lt;category android:name="$&#123;JPUSH_PKGNAME&#125;"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; Gradle 配置替换使用manifestPlaceholders=[]各属性间使用英文逗号分隔，注意空格 如： 12345manifestPlaceholders = [ QQ_SECRET : "", QQ_APPID : "" ] 当release 版本与debug需要区分时，可在buildTypes内配置 如： 12345678910111213141516buildTypes &#123; release &#123; manifestPlaceholders = [ QQ_SECRET : "", QQ_APPID : "" ] &#125; debug &#123; manifestPlaceholders = [ QQ_SECRET : "", QQ_APPID : "" ] &#125; &#125; 当不需要区分时，可在defaultConfig内配置 如： 1234567 defaultConfig &#123;manifestPlaceholders = [ QQ_SECRET : "", QQ_APPID : "" ] &#125; 代码读取读取Manifest定义好的key 12345 val appInfo = mContext?.packageManager?.getApplicationInfo(mContext?.packageName, PackageManager.GET_META_DATA)val sinaKey = appInfo?.metaData?.get("QQ_APPKEY")val sinaSecret = appInfo?.metaData?.get("QQ_SECRET") debug 包指定签名信息目的不打签名包直接运行也可实现签名包的效果，可有效减少耗时 如微信分享时，需要签名信息，每次验证都打包相对耗时较长，使用该方法，不打签名包也可实现 签名文件需在module同级目录下 gradle配置12345buildTypes &#123; debug &#123; signingConfig signingConfigs.debug &#125; &#125; 指定签名信息： 12345678signingConfigs &#123; debug &#123; storeFile file('debug.keystore') storePassword "android" keyAlias "androiddebugkey" keyPassword "android" &#125; &#125;]]></content>
      <categories>
        <category>原创</category>
        <category>android</category>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>动态替换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题升级，从5.1到6.0]]></title>
    <url>%2Fnext-theme-update.html</url>
    <content type="text"><![CDATA[以下内容根据NextGitHub提供内容进行主题更新升级验证 由于之前就做好了升级准备，尽量减少原文件的变更，相对来说工作量不是很大 6.0在一些原有的插件上的使用上还有些问题，想尝鲜的继续 基于Next6.0.1 Next主题更新升级升级方法参考由于新版本官方详细说明还未发布，这里先提前研究一下新版本 这里由原5.1.4升级到6.0.1 仓库地址发生变化5.1: git@github.com:iissnan/hexo-theme-next.git 6.0: git@github.com:theme-next/hexo-theme-next.git 使用release 版本，按官方说法是相对比较稳定，但仍存在一些问题 官方提供的方式总结为三点： clone 仓库到新目录，假设为next-reload 若主题配置使用了datafile方式，新目录也不变，原主题目录不变，可以随时还原 修改站点配置加载主题next-reload 补充： 自定义修改比较多的，可以比对更新，即合并代码 copy 新增文件到站点source目录 主题文件可先clone 后将.git文件夹移除，待成功备份到自己的仓库后，再还原移除的.git，这样既可以备份，也可以与原仓库比对更新 若仍有修改且准备提交到next仓库的，继续使用fork 升级主题未变及变更文件5.1版本修改过的文件，以及更新到6.0的变更以下变更全部从主题目录变更到站点目录，可以理解为尽量减少主题文件的修改 崩溃欺骗\layout_layout.swig\source\js\src\custom\custom-title.js 样式整站 \source\css_custom\custom.styl 侧栏，5.1新增 \source\css_custom\custom-sidebar.styl 变更为source_data\style.styl，代码融合 变量\source\css_variables\custom.styl 改为source_data\variables.styl 语言\languagues\zh-Hans 6.0主题变更文件 站点source新增及变更文件 文章结束标记\layout_macro\post.swig 原代码 12345678910111213&#123;% raw %&#125;&lt;div class=&quot;post-body ...&gt;&#123;&#123; post.content &#125;&#125;&lt;div style=&quot;text-align:center;color: #ccc;font-size:18px;&quot;&gt;—— The End ——&lt;/div&gt;&#123;&#123; post.content &#125;&#125;` &lt;div style=&quot;text-align:center;color: #ccc;font-size:18px;&quot;&gt;—— The End ——&lt;/div&gt;&lt;/div&gt;&#123;% endraw %&#125; 修改为： 添加到postbody div之后 12345678&#123;% raw %&#125;&lt;div class=&quot;post-body &gt;&lt;/div&gt;&#123;% if not is_index and theme.post_end %&#125;&lt;!-- noindex--&gt;&lt;div class=&quot;post-end text-center&quot;&gt;&lt;span &gt;&#123;&#123;theme.post_end&#125;&#125;&lt;/span&gt;&lt;/div&gt;&#123;% endif %&#125;&#123;% endraw %&#125; source_data\style.styl样式新增： 12345//文章结束标识.post-end&#123; font-size: 18px color: #ccc&#125; 主题配置 1post_end: &lt;i class=&quot;fa fa-signing fa-lg&quot;&gt;&lt;/i&gt; The End &lt;i class=&quot;fa fa-signing fa-lg&quot;&gt;&lt;/i&gt; 由于小屏幕一些文字不显示，去除原图标控制逻辑 第三方评论仍选择支持双评论系统，删除的代码有变化 \layout_third-party\comments\disqus.swig\layout_third-party\comments\gitment.swig\layout_third-party\comments\gitment.swig 评论组合评论，5.1新增 \layout\partials\comments\custom-comments.swig 改为： source_data\comments.swig 主题配置custom_file_path新增字段comments:12custom_file_path: comments: source\_data\comments.swig 这部分在双评论系统文章有详细讲解 评论整体布局\layout_partials\comments.swig参考header修改 由 {% include /comments/custom-comments.swig %} 变更为 123456&#123;% raw %&#125;&#123;% if theme.custom_file_path.comments %&#125;&#123;% set custom_comments = &apos;../../../../&apos; + theme.custom_file_path.comments %&#125;&#123;% endif %&#125;&#123;% include custom_comments %&#125;&#123;% endraw %&#125; 6.0.1的一些问题点 主题配置 除新增变更功能外，其他不变 第三方评论 disqus 代码发生变化，双评论系统代码添加方法不变 livere 代码发生变化，支持双评论系统代码修改方法不变 post_word_count 替换为 symbols_count 官方GitHub 安装插件 npm install hexo-symbols-count-time –save 站点、主题配置 ：配置参照官网 注意：需要修改语言文件 zh-Hans.yml文件post参数:增加：1234symbols_count: 字数统计symbols_time: 阅读时长约total_symbols: Symbols count totaltotal_time: Reading time total 时间计算方式变更，结果及显示与之前不太一样 文章版权由于显示有问题，这里做个修改 zh-Hans.yml文件 修改：license_content: ‘本博客所有文章除特别声明外，均采用%s 许可协议。转载请注明出处！’ footer与主体间距 距离过小会遮挡分页按钮修改source\styles.styl //主体与footer间距$gap-between-main-and-footer = 120px 插件变更及启用功能变更algolia搜索 nextalgolia 新建\source\lib\algolia-instant-search 添加文件instantsearch.min.css,instantsearch.min.js 主题配置不变 local_search 启用后一直加载，具体原因未知 背景动画Canvasthree_waves路径：themes\next\source\lib\threethemes\next\source\lib\canvas-nest主题配置开启123456789canvas_nest: true# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false 新增功能reading_progressreading_progressJs文件 source\lib\reading_progress路径 主题配置： 12reading_progress: enable: true Fllow Me On GitHub主题配置 1github_banner: https://github.com/yourname || Follow me on GitHub 页面右上角显示 不喜欢的可以继续使用之前_layout.swig 文件body内增加代码的方式 启用原有功能needmoreshare2needmoreshare2js文件 source\lib\needmoreshare2 主题配置： 1234567needmoreshare2: enable: true postbottom: enable: true float: enable: false Star Rating获取id 主题配置： 123rating: enable: true id: #4位id]]></content>
      <categories>
        <category>原创</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>实战</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客-双评论系统（来必力与Disqus）]]></title>
    <url>%2Fcombined-comments.html</url>
    <content type="text"><![CDATA[前言：看到next issue 有人提出双评论系统的问题，实现方案及效果各不同 正好我也考虑实现类似的双评论系统方案 为方便主题升级及管理修改方便，特此研究了一下实现原理，按照此文所讲述方式，实现自己的组合评论系统也不难 以下内容基于Next 5.1.4实现，支持主题升级，原理不变，细节会有变化 Next官方已经发布6.0.2版本，将延时加载加入了disqus。 双评论系统原理：主要修改布局代码，配合主题配置控制显示 双评论效果演示演示来必力与Disqus组合，gitment暂时未启用 主题配置来必力默认只有livere_uid，需要新增配置 123livere:#新增 enable: true#新增，控制评论显示 livere_uid: xxxxxxx 第三方评论模板支持 themes\next\layout\third-partycomments\xxx.swig文件 删除自己开启条件之外的控制语句，注意最后的endif 也要删除 如： gitment 12345678910&#123;% raw %&#125;&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname %&#125;&#123;% if theme.gitment.enable and theme.gitment.client_id %&#125;&lt;!-- LOCAL: You can save these files to your site and update links --&gt; #省略&#123;% endif %&#125;&lt;!-- END LOCAL --&gt;&#123;% endraw %&#125; 删除最外围的 {% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname %} {% endif %} 来必力 1234567891011&#123;% raw %&#125;&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not (theme.disqus.enable and theme.disqus.shortname) and not theme.hypercomments_id %&#125; &#123;% if page.comments and theme.livere_uid %&#125; #省略 &#123;% endif %&#125;&#123;% endif %&#125;&#123;% endraw %&#125; 删除最外围的 {% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not (theme.disqus.enable and theme.disqus.shortname) and not theme.hypercomments_id %}{% endif %} Disqus 1234567891011&#123;% raw %&#125;&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname %&#125; &#123;% if theme.disqus.enable %&#125; #省略 &#123;% endif %&#125;&#123;% endif %&#125;&#123;% endraw %&#125; 删除最外围的 {% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname %}{% endif %} 上述代码主题升级到6.0.1时有变化，原理不变 布局顺序调整按所需顺序调整comments各评论系统div顺序，我的顺序从上到下是来必力gitmentdisqus 整体评论布局支持 创建themes\next\layout_partials\comments\custom-comments.swig模板文件 组合需要在一起显示的评论系统，用一个div 承载，好处是如果添加了背景，可以将几个评论系统显示在一起。 条件语句使用逻辑或控制整体div显示，每个评论系统自己控制逻辑不变 核心代码： 123456789101112131415161718192021&#123;% raw %&#125;&#123;% if theme.livere.enable or theme.gitment.enable or theme.disqus.enable %&#125; &lt;div class="comments" id="comments"&gt; &#123;% if theme.livere.enable %&#125; #来必力核心代码 &#123;% endif %&#125;​ &#123;% if theme.gitment.enable %&#125; # gitment核心代码 &#123;% endif %&#125; &#123;% if theme.disqus.enable %&#125; # disqus 核心代码 &#123;% endif %&#125;​ &lt;/div&gt;&#123;% endif %&#125;&#123;% endraw %&#125; \themes\next\layout_partials\comments.swig 文件末尾引入上述模板 {% include 'comments/custom-comments.swig' %} 注意：此代码在主题升级到6.0.1时会有变化，如下 12345678&#123;% raw %&#125;&#123;% if theme.custom_file_path.comments %&#125; &#123;% set custom_comments = &apos;../../../../&apos; + theme.custom_file_path.comments %&#125;&#123;% endif %&#125;&#123;% include custom_comments %&#125;&#123;% endraw %&#125; 放在末尾可以覆盖前面的配置 这样做的好处是，减少原comments模板文件的修改，方便升级更新 添加或修改disqus 加载按钮位置 按钮放置于所有评论系统div之前 点击加载之后，将加载出的Disqus置于已有评论之后 添加以下代码到模板 123&lt;div style="text-align:center;"&gt;&lt;button class="btn" id="load-disqus" onclick="disqus.load();"&gt;加载 Disqus 评论&lt;/button&gt;&lt;/div&gt; custom-comments完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243&#123;% raw %&#125;&#123;% if page.comments %&#125;&#123;% if theme.disqus.enable %&#125; &lt;div style="text-align:center;"&gt; &lt;button class="btn" id="load-disqus" onclick="disqus.load();"&gt;加载 Disqus 评论&lt;/button&gt; &lt;/div&gt;&#123;% endif %&#125; #核心代码&#123;% if theme.livere.enable or theme.gitment.enable or theme.disqus.enable %&#125; &lt;div class="comments" id="comments"&gt; &#123;% if theme.livere.enable %&#125;#使用主题配置来必力新增控制 &lt;div id="lv-container" data-id="city" data-uid="&#123;&#123; theme.livere.livere_uid &#125;&#125;"&gt;&lt;/div&gt; &#123;% endif %&#125; &#123;% if theme.gitment.enable %&#125;#gitment &#123;% if theme.gitment.lazy %&#125; &lt;div onclick="showGitment()" id="gitment-display-button"&gt;&#123;&#123; __('gitmentbutton') &#125;&#125;&lt;/div&gt; &lt;div id="gitment-container" style="display:none"&gt;&lt;/div&gt; &#123;% else %&#125; &lt;div id="gitment-container"&gt;&lt;/div&gt; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% if theme.disqus.enable %&#125;# disqus &lt;div style="text-align:center;"&gt; &lt;/div&gt; &lt;div id="disqus_thread"&gt; &lt;noscript&gt; Please enable JavaScript to view the &lt;a href="https://disqus.com/?ref_noscript"&gt;comments powered by Disqus.&lt;/a&gt; &lt;/noscript&gt; &lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% endif %&#125;&#123;% endif %&#125;&#123;% endraw %&#125; 参考,感谢大佬 chalkitehlxr]]></content>
      <categories>
        <category>原创</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Git</tag>
        <tag>Hexo</tag>
        <tag>Node.js</tag>
        <tag>实战</tag>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客，从填坑到上天]]></title>
    <url>%2Fpersonal-blog-advanced.html</url>
    <content type="text"><![CDATA[前言： 对博客做一些扩展，增加一些交互功能，如搜索、评论、订阅等 教你如何多端同步修改，博客源码托管 站内搜索LocalSearch安装 npm install hexo-generator-searchdb --save 站点配置文件： 12345search: path: search.xml field: post format: html limit: 10000 主题配置文件： 12local_search: enable: true aloglia 流程参考Next主题官网第三方服务 GitHub-algolia 过程官方已经说明，这里补充一些细节 添加index随意起，如：personal_blog，此项一定要有，需要添加到站点配置 编辑ApiKey 权限ACL：选中 Search这里与algolia-github有出入，我们需要选中search 不选中此项，站点搜索输入无结果 当前api所有权限： indices 选取我们前面添加的indexName，可选 Update保存 复制id及api key此处配置时需要注意保密Search-Only API Key 是我们需要添加到配置中的，也是我们上面编辑过权限的 站点配置123456algolia: applicationID: ********** apiKey: a68d6525********** #替换Search-Only API Key indexName: personal_blog #替换indexName chunkSize: 5000 adimnApiKey: ********** #可不填，没实际意义 启用Algolia12345678algolia_search: enable: true hits: per_page: 10 labels: input_placeholder: 开始你的搜索... #自定义搜索默认 hits_empty: &quot;没有你要找的：$&#123;query&#125; &quot;#无结果提示 hits_stats: &quot;找到 $&#123;hits&#125;条结果，用时 $&#123;time&#125;毫秒&quot; #结果提示 导入博客到index博客根目录 安装插件 npm install --save hexo-algolia 配置环境变量 使用你自己的Search-Only API Key export HEXO_ALGOLIA_INDEXING_KEY=****************** 注意：windows 环境的命令是export 不是set 更新index hexo algolia 当出现 123INFO [Algolia] Identified xx pages and posts to index.INFO [Algolia] Indexing chunk 1 of 1 (xx items each)INFO [Algolia] Indexing done. 表明博客导入成功 注意： 1.apikey或applicationid不一致这里会出错。需与algolia官网获取的保持一致 2.博客文章发生变化需要清空原index,重新更新index,否则将出现搜索不到或已删除、变更之前的内容 3.当出现下面的提示时，表明key 发生变化或者不对，需要重新配置apikey变量 验证搜索效果hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 上面的两种方式均为在next主题下弹框方式，其他搜索方式待补充 评论系统评论系统由于多说、网易跟帖已关闭，目前已知有三种方式可选，Disqus，gitment,来必力下面依次说明启用方式 DisqusDisqus,需科学上网 由shortname作为唯一标识 获取’shortName’ 右侧，Admin 选项 进入创建页面 注册网址，编辑’shortName’,保存 进入Settings/general页面,确认’shortName’ disqus可以创建多个站点，根据需要配置不同类型与’shortName’ 启用评论系统添加到主题配置 1234disqus: enable: true #启用 shortname: ********#替换你自己的shortname count: false #自行决定 验证效果,必须科学上网 对用户友好处理原理：通过按钮点击加载Disqus，使用主题默认样式 [参考][参考]layout_third-partycomments\disqus.swig定义方法 1234567var disqus = &#123;load : function disqus()&#123; //原disqus核心代码 $('#load-disqus').remove(); &#125;&#125; themes\next\layout_partials\comments.swig增加代码，添加定义好方法： 123&lt;div style="text-align:center;"&gt;&lt;button class="btn" id="load-disqus" onclick="disqus.load();"&gt;加载 Disqus 评论&lt;/button&gt;&lt;/div&gt; 修改后的 disqus.swig 代码为： 123456789101112131415161718192021222324252627&#123;% raw %&#125;#省略&#123;% if page.comments %&#125; &lt;script type="text/javascript"&gt; var disqus = &#123; load : function disqus()&#123; var disqus_config = function () &#123; this.page.url = '&#123;&#123; page.permalink &#125;&#125;'; this.page.identifier = '&#123;&#123; page.path &#125;&#125;'; this.page.title = '&#123;&#123; page.title| addslashes &#125;&#125;'; &#125;; var d = document, s = d.createElement('script'); s.src = 'https://&#123;&#123;theme.disqus.shortname&#125;&#125;.disqus.com/embed.js'; s.setAttribute('data-timestamp', '' + +new Date()); (d.head || d.body).appendChild(s); $('#load-disqus').remove(); &#125; &#125; &lt;/script&gt;&#123;% endif %&#125;#省略&#123;% endraw %&#125; 来必力获取data-uid首次登录时 chrome 反应比较慢，建议换其他浏览器，注意发送到注册邮箱的验证码 选择安装版本，选择个人版，获取data-uid 启用主题配置，打开livere_uid，填写uid 注意：此时需要关闭主题配置启用的其他评论系统，原代码逻辑采用的是只开启一种评论系统 验证 增加开关控制 主题配置 123livere:#新增 enable: true#新增，控制评论显示 livere_uid: xxxxxxx livere.swig 模板修改 增加theme.livere.enable引用 123456&#123;% raw %&#125;&#123;% if page.comments and theme.livere.enable and theme.livere.livere_uid %&#125;&#123;% endif %&#125;&#123;% endraw %&#125; comments.swig 模板 原theme.livere_uid变更为：theme.livere.livere_uid 注意：上述评论系统代码在主题更新到6.0之后会有变化 双评论系统实现原理不变，具体方案有变化 gitmentRSS安装插件npm install hexo-generator-feed --save 主题修改rss: /atom.xml 效果:chrome浏览器没做解析，所以不用关心显示问题，正常现象 firefox ，ie浏览器显示正常，效果不太一样。可自行验证 seo 相关文章尽量为英文名称，短路径，修改站点配置，permalink如下： 123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursiteroot: /permalink: :title.htmlpermalink_defaults: 多端同步Hexo源文件各网站需添加访问公钥，这里演示三个比较流行的代码托管网站，github ，gitee ,coding 多仓库操作删除本地已关联的origin仓库git remote rm origin 关联远程仓库 coding 需新建仓库，使用此仓库名称与本地关联 gitee 与coding 由于可以将仓库设置为私有，因此可以将源码上传， 发布地址上述3个网站需要有选择性添加 ​ 下面演示三个都关联,gitee、coding 新建仓库，注意仓库名称与用户名称保持一致 1234567891011$ git remote add github git@github.com:username/repo.git$ git remote add gitee git@gitee.com:username/repo.git$ git remote add coding git@git.coding.net:username/repo.git$ git remote -vcoding git@git.coding.net:username/repo.git (fetch)coding git@git.coding.net:username/repo.git (push)gitee git@gitee.com:username/repo.git (fetch)gitee git@gitee.com:username/repo.git (push)github git@github.com:username/repo.git (fetch)github git@github.com:username/repo.git (push) 多个仓库部署发布参考hexo同时部署到coding(gitcafe)和github 若同时发布 站点配置： 1234567repository: #发布到github github: git@github.com:username/repo.git #发布到gitee gitee: git@gitee.com:username/repo.git #发布到coding coding:git@git.coding.net:username/repo.git 注意： 由于coding有广告，免广告需单独修改主题配置，站点发布仓库需区分处理若单仓库发布 站点配置不变 repository: git@github.com:username/repo.git GitHub 优点：仓库数量不限， 缺点：仓库公开，任何人都可以随意fork，国内访问速度慢，容量限制 新建仓库，推送本地代码 coding 优点： 据说访问速度快 缺点： 无法直接导入仓库，仓库数量限制，256m容量限制，想更高需软妹币 新建仓库，推送本地代码 注意：Hosted by Coding Pages 免广告页面申请需单独配置，最简单的只需修改主题配置custom_text即可 文字形式： 主题配置 123custom_text: #发布到coding需打开，发布到除coding之外的其他托管网站，可以注释掉 Hosted by &lt;a href=&quot;https://pages.coding.me&quot;&gt;Coding Pages&lt;/a&gt; 图片形式：可参考coding官网 Gitee 优点：仓库可以为私有，安全 ,企业用户 缺点：仓库超400m，限制svn访问 可直接从github 导入仓库，或上述方法 注意 gitee分支属性需设置为常规分支，否则其他端无法读写代码 coding 分支属性设置之后无法变更，谨慎操作 经验证发现coding、gitee仓库名需与用户名一致，否则css失效 gitee 与coding发布站点需启用pages 上传源码将本地当前所在分支上传到远程指定分支 源码上传到gitee 分支为hexo git push gitee hexo 源码上传到coding git push coding hexo 注意敏感信息配置文件不要上传，当然仓库为私有的话，就无所谓了 由于github只能公开仓库，因此源码不再上传到github 备份流程 参考cherry 自行修改备份源文件仓库地址，github、gitee 、coding 备份源文件流程配置原.gitignore文件，添加需要忽略的文件 如：关键信息、文章源文件、配置等 我的配置： 123456789101112.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*//.deploy_git/_config.ymlnext.yml package.jsonpackage-lock.json 忽略原则可自行配置 站点目录下删除自带.git文件夹 123git init` #创建仓库git checkout -b hexo #创建并切换到hexo分支 注：此分支用于存储需要同步的源文件，此分支是否为默认分支大何影响，非默认分支时我们在push时指定该分支，远程master分支属于站点分支，不能存储源文件，当我们本地编译发布时会自动更新，无需操心 1234567891011121314git add .git commit -m &quot;添加源文件&quot;#关联到giteegit remote add gitee git@gitee.com:&lt;username&gt;/&lt;repo&gt;.git#关联到codinggit remote add coding git@git.coding.net:&lt;username&gt;/&lt;repo&gt;.git#推送代码git push --set-upstream gitee hexo或`git push gitee hexo` :push到远端git push coding hexo 备份主题文件 如果定制程度不高，仅修改了配置文件，可以采用DataFile的方式备份 即：将主题配置修改过的信息单独存放于\source_data\next.yml文件，原主题配置文件改为override： true 如果主题定制程度比较高的话，建议使用下面的方法进行备份，注意，不要泄露主题配置文件内的敏感信息 参考 主题需先fork 到自己的github仓库，删除git 及.gitignore文件，可直接push 到博客源仓库，不删除这俩文件，可push到自己的fork 仓库 按上述方法push效果如下图： 注意：经试验证实，搭建博客时clone 的主题文件属于Next 官网，我们在上传本地源文件时即使删除了.git等文件也无法成功上传 ，此时我们自己修改后的主题文件需要备份，再使用上面提到的方法，覆盖修改过的文件后再上传 关于主题更新的问题待研究出可行方案再补充目前的一个思路是：fork后clone 的本地仓库保留，next官网更新主题后可直接远程拉取最新提交，再与本地比对合并，有机会可以验证一下 其他端后续操作 本地无仓库代码时 git clone ,无需 init，因为已经包含了原git仓库 本地已存在仓库时 git pull 时，指定远程仓库分支 如： coding ：git putll coding hexo gitee : git pull gitee hexo github: git pull github hexo 推送代码 coding: git push coding hexo gitee: git push gitee hexo github: git push github hexo 插件总结自动部署Git 插件npm install hexo-deployer-git --save 分页123npm install --save hexo-generator-indexnpm install --save hexo-generator-archivenpm install --save hexo-generator-tag 文章字数统计阅读时长npm install hexo-wordcount --save 搜索localSearchnpm install hexo-generator-searchdb --save algolianpm install --save hexo-algolia 至此，Hexo 搭建博客相关内容告一段落，剩下的就是看到好玩的东西会临时加一下到博客，同步更新实现方案 博客文章添加代码且高亮方法md文件引入代码 代码高亮站点配置： 12345highlight: enable: true line_number: true auto_detect: true tab_replace: 站点加速关闭默认字体1234567891011121314151617181920212223242526272829font: enable: false global: external: false family: Lato size: headings: external: false family: size: posts: external: false family: logo: external: false family: size: codes: external: false family: size: 浏览器自动部署使用hexo的hexo-browersync插件安装插件：npm install hexo-browersync --savehexo s 吃水不忘挖井人 ，感谢以下大神 南尘 | Zippera | diygreen | cherry | 知乎| ehlxr | chalkit]]></content>
      <categories>
        <category>原创</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Git</tag>
        <tag>Hexo</tag>
        <tag>Node.js</tag>
        <tag>实战</tag>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客，从入坑到填坑]]></title>
    <url>%2Fpersonal-blog-custom.html</url>
    <content type="text"><![CDATA[前言： 静态网站建立之后我们需要对其做些细节修改 此博文包括文章、整站的一些细节修改，并增加一些统计功能 站点细节大部分内容都能从官网找到，这里做个备忘录 头像设置参考Next官网 主题配置文件 按描述路径放置图片，图片格式不重要，但必须为有效图片 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.jpg 网站logo此logo为页面在浏览器标签上显示图片 制作网站 命名为.ico或.png文件存放于sources\images\路径 主题配置： 12345favicon: small: /images/favicon-16x16.ico medium: /images/favicon-32x32.png 设置阅读全文参考官网) 分页插件安装 123npm install --save hexo-generator-indexnpm install --save hexo-generator-archivenpm install --save hexo-generator-tag 站点配置文件 123456789101112index_generator:path: &apos;&apos;per_page: 5order_by: -datearchive_generator:per_page: 20yearly: truemonthly: truetag_generator:per_page: 10 社会化链接 图标名称获取 这里只需要替换自己想要的图标名称即可 主题配置social标签，打开或添加对应项，替换链接 文本的居中引用以下三种任选其一，直接在md文件插入 1231. &lt;blockquote class=&quot;blockquote-center&quot;&gt;blah blah blah&lt;/blockquote&gt;2. &#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;3. &#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; 背景动画 默认的无需插件安装 ：canvas_nest 与three_waves 二选一 隐藏强力驱动直接修改配置文件 1234footer: powered: false theme: enable: false 网页底部图标图标名称 主题配置：footer: icon： xxx修改themes\next\layout_partials\footer.swig footer.icon关键字 图标放大： 123456#原图：&lt;i class="fa fa-&#123;&#123; theme.footer.icon &#125;&#125;"&gt;&lt;/i&gt;#1倍：&lt;i class="fa fa-&#123;&#123; theme.footer.icon &#125;&#125; fa-lg"&gt;&lt;/i&gt;#2倍：&lt;i class="fa fa-&#123;&#123; theme.footer.icon &#125;&#125; fa-2x"&gt;&lt;/i&gt; 文章相关文章版权声明 主题配置 12post_copyright: enable: true 站点配置 url:http://yoururl.com #添加自己的url 最终会生成当前文章的完整url 文章底部添加’The End’\themes\next\layout_macro\post.swigpost-body divpost.content 关键字 结束后 添加1&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;—— The End ——&lt;/div&gt; 如下： 123456789101112&lt;div class=&quot;post-body...&gt;#省略&#123;% if post.type === &apos;picture&apos; %&#125;&lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt;&#123;&#123; post.content &#125;&#125;&lt;/a&gt;&#123;% else %&#125;&#123;&#123; post.content &#125;&#125;&lt;div style=&quot;text-align:center;color: #ccc;font-size:18px;&quot;&gt;—— The End ——&lt;/div&gt;#省略&#123;&#123; post.content &#125;&#125;&lt;div style=&quot;text-align:center;color: #ccc;font-size:18px;&quot;&gt;—— The End ——&lt;/div&gt;&#123;% endif %&#125;&lt;/div&gt; 添加位置不对容易出现 在首页 文章底部标签‘#’修改\themes\next\layout_macro\post.swig post-tags关键字： 12345678&lt;footer class="post-footer"&gt; &#123;% if post.tags and post.tags.length and not is_index %&#125; &lt;div class="post-tags"&gt; &#123;% for tag in post.tags %&#125; &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;% endif %&#125; rel=&quot;tag&quot;&gt;#替换为： 1rel="tag"&gt;&lt;i class="fa fa-tag"&gt; &lt;/i&gt; 文章小图标主题配置 定义： post #控制文章图标显示 icon: false 需要处理图标的找到对应图标，添加类似下面的代码来控制图标的显示： &lt;% if theme.xxx.icon %&gt; &lt;% endif %&gt; xxx为当前元素标识修改文件：\themes\next\layout_macro\post.swig找到 icon字符串 字数统计与阅读时间图标post_wordcount 关键字 123456789&#123;% raw %&#125; &#123;% if theme.post_wordcount.wordcount %&#125; #省略 &lt;span class="post-meta-item-icon"&gt; #这个是图标 &lt;i class="fa fa-file-word-o"&gt;&lt;/i&gt; &lt;/span&gt; #省略 &#123;% endif %&#125;&#123;% endraw %&#125; 改为： 12345678910&#123;% raw %&#125;&#123;% if theme.post_wordcount.wordcount %&#125; #省略 &#123;% if theme.post_wordcount.icon %&#125;#新增图标控制 &lt;span class="post-meta-item-icon"&gt;#这个是图标 &lt;i class="fa fa-file-word-o"&gt;&lt;/i&gt; &lt;/span&gt; &#123;% endif %&#125; #省略&#123;% endraw %&#125; min2read 关键字 12345678&#123;% raw %&#125;&#123;% if theme.post_wordcount.min2read %&#125; &lt;span class="post-meta-item-icon"&gt; #这个是图标 &lt;i class="fa fa-clock-o"&gt;&lt;/i&gt; &lt;/span&gt; #省略&#123;% endif %&#125;&#123;% endraw %&#125; 改为： 123456789&#123;% raw %&#125;&#123;% if theme.post_wordcount.min2read %&#125; &#123;% if theme.post_wordcount.icon %&#125;#新增图标控制 &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-clock-o"&gt;&lt;/i&gt; &lt;/span&gt;&#123;% endif %&#125;#省略&#123;% endraw %&#125; 发表、更新等时间图标created_at 123456789&#123;% raw %&#125; &lt;span class="post-time"&gt; &#123;% if theme.post_meta.created_at %&#125; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-calendar-o"&gt;&lt;/i&gt; &lt;/span&gt; #省略&#123;% endif %&#125;&#123;% endraw %&#125; 改为： 123456789101112&#123;% raw %&#125;&#123;% if theme.post_meta.created_at %&#125; &#123;% if theme.post_meta.icon %&#125;#新增图标控制 &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-calendar-o"&gt;&lt;/i&gt; &lt;/span&gt; &#123;% endif %&#125; #省略&#123;% endif %&#125;&#123;% endraw %&#125; updated_at 12345678&#123;% raw %&#125;&#123;% if theme.post_meta.updated_at %&#125; &lt;span class="post-meta-item-icon"&gt;#图标 &lt;i class="fa fa-calendar-check-o"&gt;&lt;/i&gt; &lt;/span&gt; #省略&#123;% endif %&#125;&#123;% endraw %&#125; 改为：12345678910&#123;% raw %&#125; &#123;% if theme.post_meta.updated_at %&#125; &#123;% if theme.post_meta.icon %&#125;#新增图标控制 &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-calendar-check-o"&gt;&lt;/i&gt; &lt;/span&gt; &#123;% endif %&#125; #省略&#123;% endif %&#125;&#123;% endraw %&#125; 文章评论计数图标disqus.count关键字 ，主题配置设置为flase，最简单 或者按上述方法添加代码 1234567891011&#123;% raw %&#125;&#123;% elseif theme.disqus.enable and theme.disqus.count %&#125; &lt;span class="post-comments-count"&gt;&#123;% if theme.disqus.icon %&#125;#新增图标控制 &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-comment-o"&gt;&lt;/i&gt; &lt;/span&gt;&#123;% endif %&#125;&#123;% endraw %&#125; 阅读时长min2read 关键字 增加时间单位 语言文件 \themes\next\languagues\zh-Hans 增加 min2read_unit: 分钟 增加下面代码，去除多余符号 1&lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.min2read_unit') &#125;&#125;&lt;/span&gt; post文件修改： 1234567891011121314&#123;% raw %&#125;&#123;% if theme.post_wordcount.min2read %&#125;#省略&lt;span class="post-meta-item-text"&gt;&#123;&#123; ('post.min2read_unit') &#125;&#125;&lt;/span&gt;&#123;% if theme.post_wordcount.item_text %&#125; &lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.min2read') &#125;&#125; &amp;asymp; &lt;/span&gt;#待去除符号&#123;% endif %&#125; &lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt;&#123;&#123; min2read(post.content) &#125;&#125; &lt;/span&gt; #待加入新代码&#123;% endif %&#125;&#123;% endraw %&#125; 改为 1234567891011121314&#123;% raw %&#125;&#123;% if theme.post_wordcount.min2read %&#125;#省略&#123;% if theme.post_wordcount.item_text %&#125; &lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.min2read') &#125;&#125;&lt;/span&gt;#去除符号 &#123;% endif %&#125; &lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; &lt;/span&gt;&lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.min2read_unit') &#125;&#125;&lt;/span&gt;#新加入的代码&#123;% endif %&#125;&#123;% endraw %&#125; 上述几处修改效果： 相关统计文章字数与阅读时长 安装 wordcount 插件 npm install hexo-wordcount --save 主题配置 1234567post_wordcount: item_text: true #整体 wordcount: true # 字数 min2read: true # 时间 totalcount: false #阅读统计 separated_meta: true #分割元素控制 icon: false #新增项，控制图标显示 文章阅读次数使用 leancloud 注册拿到app_id及app_key 启用 主题配置 1234leancloud_visitors enable: true app_id: xxxxxxxxxxxxxxxxxxxxxxxxxx app_key: xxxxxxxxxxxxxxxxxxxxxxxxxx 文章阅读数热度： 需要leanCloud id 及key themes\next\layout_macro\post.swig 文件 123&lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;/span&gt;#待新增符号 新增符号： 12 &lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;&lt;span&gt;℃&lt;/&gt;#新增符号 zh_Hans.yml visitors: 热度 #原词修改为“热度” 站点访问推荐使用高版本，毕竟相对来说配置简单不蒜子统计uv 与pv：主题配置文件 修改: 12busuanzi_count: enable :true 以下配置：true 为开启，false 为关闭 123456789101112131415busuanzi_count:# count values only if the other configs are false enable: true# custom uv span for the whole site 全站访问人数 site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;访问人数&lt;/i&gt; site_uv_footer: 人# custom pv span for the whole site 全站访问次数 site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;访问次数&lt;/i&gt; site_pv_footer: 次# custom pv span for one page only 每篇文章访问次数 page_pv: false page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;本文总阅读量&lt;/i&gt; page_pv_footer: 次 去除图标：删除即可 上述几处效果： 其他及一些好玩的Frok Me On GitHub 选定代码GitHub Ribbons 添加themes\next\layout_layout.swig，添加到body内 标红处替换为你自己的github地址 头像旋转效果参考 方案参考： next\source\css\main.styl 为方便主题更新，代码改动比较大的原则上尽量使用自定义文件导入的方式。 优化实现方案： 自定义css 文件命名为custom-sidebar.styl 完整路径：themes\next\source\css_custom\custom-sidebar.styl 引入自定义css，原文件主体代码不改动 themes\next\source\css_common\components\sidebar\sidebar-author.styl 模板末尾 @import &quot;../../../_custom/custom-sidebar&quot;; 再加个放大效果custom-sidebar.styl文件完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970.site-author-image &#123; /*头像圆形*/ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ -webkit-animation: play 2s ease-out 1s 1; -moz-animation: play 2s ease-out 1s 1; animation: play 2s ease-out 1s 1; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125;img:hover &#123;/* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度，放大 */ -webkit-transform: rotateZ(360deg) scale(1.1); -moz-transform: rotateZ(360deg) scale(1.1); transform: rotateZ(360deg) scale(1.1);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 页面自定义样式参考 添加到themes\next\source\css_custom.styl footer与文章内容间距根据：source\css_common\outline\outline.styl 123// Main Section// --------------------------------------------------.main &#123; padding-bottom: $footer-height + $gap-between-main-and-footer; &#125; 修改： \themes\next\source\css_variables\custom.styl样式文件 $gap-between-main-and-footer = 40px \themes\next\source\css_custom\custom.styl 添加代码： 12345//页脚.footer&#123; margin-top: 20px; margin-bottom: 10px;&#125; 设置动态title崩溃欺骗\themes\next\source\js\src，新建custom-title.js 12345678910111213141516&lt;!--崩溃欺骗--&gt;var OriginTitile = document.title;var titleTime;document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel="icon"]').attr('href', "/img/TEP.ico"); document.title = ' 页面崩溃啦 ~ ！'; clearTimeout(titleTime); &#125; else &#123; $('[rel="icon"]').attr('href', "/favicon.ico"); document.title = ' 噫又好了~ ' + OriginTitile; titleTime = setTimeout(function () &#123; document.title = OriginTitile;&#125;, 2000); &#125;&#125;); 更改 \themes\next\layout_layout.swig 。在 &lt;/body 之前添加： 12&lt;!--卖萌--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/custom/custom-title.js&quot;&gt;&lt;/script&gt; High一下注意：主题升级文件路径有变化，代码不变来源：zipperary，感谢大神 修改原则：减少源码修改，尽量使用自定义文件方式 header位置可添加到themes\next\layout_custom\header.swig sidebar位置可添加到themes\next\layout_custom\sidebar.swig 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;li&gt; &lt;a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125;&#125;)() '&gt;High一下&lt;/a&gt; &lt;/li&gt;]]></content>
      <categories>
        <category>原创</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Git</tag>
        <tag>Hexo</tag>
        <tag>Node.js</tag>
        <tag>实战</tag>
        <tag>中级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客，从入坑开始]]></title>
    <url>%2Fpersonal-blog-start.html</url>
    <content type="text"><![CDATA[前言： Node.js+Hexo+Next+Git+GitHub，让你几分钟就能创建一个博客 网上很多资料由于版本原因，实现方法已经发生变化，这里贴出一些新版本更方便的方法，如果失效，请联系我 本系列文章 所提及方案全部经过实验证明有效，基于Node 8.9.4,Hexo 3.4.4 ,Next 5.1.4 talk is cheap ,下面开始 必须准备Node.js Git GitHub 账户及仓库 安装nodejsHexo 的安装创建博客目录，该目录下 ：git bash 输入命令： npm install -g hexo-cli 创建hexo文件夹博客目录下 hexo init 安装依赖包npm install 站点配置必须要改动的 123456789title: xxx # 博客名，站点名称author: xxx # 博客作者名字description: xxx # 对站点的描述，搜索引擎会抓取，可以自定义language: zh-Hans # 语言 简体中文theme: next # 配置主题，后面会讲到主题配置 发布必须要增加的 1234deploy: # 部署相关配置 type: git # 使用 Git 提交 repository: git@github.com/username/username.github.io.git# 博客仓库地址 #repository: https://github.com/xxx/xxx.github.io.git 注意：nodejs 3.0版本以上不再使用：https://github.com/username/username.github.io.git 本地查看默认站点生成文件 hexo g 或 hexo generate 启动服务 hexo s 或 hexo server 浏览器输入localhost:4000查看 发布，部署到github确认站点配置文件配置正确 1234deploy: type: git repository: https://github.com:username/username.github.io.git branch: master 发布hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 发布无反应且页面为404时： 站点配置：repository: git@github.com:path/username.github.io.git，GitHub仓库需为username.github.io 每次修改本地配置文件后，需要hexo generate才能保存。每次使用命令时，都要在博客所在目录下进行。 恭喜，博客已经初步创建成功 发布文章hexo new &quot;博客文章文件名&quot; 或新建md文件放到\source_posts文件夹或其子文件夹中 文章要按照规定格式书写 如：123456789---title: 个人博客搭建详解（Windows和Mac通用版） # 这是标题tags: # 这里写的标签会自动汇集到 tags 页面上- 实用 # 可配置多个标签，注意格式- 个人博客category: # 这里写的分类会自动汇集到 categories 页面上，分类可以多级- 实用技术 # 一级分类- 个人博客 # 二级分类--- 本地预览文章清除缓存： hexo clean生成静态网页： hexo g预览： hexo s 注意 已发布的文章发生修改， 可直接预览，即 不执行上述3个命令,刷新浏览器即可; 远程部署必须要执行上述命令 修改内容一旦预览与修改不一致，则需要clean 也可一次性执行：hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 创建分类及标签页面分类命令：hexo new page &quot;categories&quot; 找到 index.md文件编辑： 增加页面类型： type: “categories” #将页面的类型设置为categories 标签hexo new page &quot;tags&quot; index.md文件设置页面类型:type: “tags” 站点配置：启用分类及标签，清除缓存，生成页面，启动服务预览，无问题后发布 404页面hexo new page &quot;404&quot; 编辑source\404.md 即可 \404页面参考Next 主题修改下载git clone https://github.com/iissnan/hexo-theme-next themes/next 建议：若想多端同步修改博客，最好先将此主题fork到自己github仓库，再下载。否则，无法对主题进行push，此处有坑，若无此需求，无视 启用主题文件拷贝到themes目录下 站点配置文件theme：nexthexo generate 保存 主题配置文件打开任意一项 12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 验证hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 博客已经初步完成。 Hexo相关命令总结1234567891011121314151617hexo clean #清除缓存hexo g #保存修改，生成文件hexo s #启动本地服务hexo d #发布到远程hexo init #生成站点hexo new page &quot;xxx&quot; #生成页面hexo new &quot;&quot; #生成文章npm install --save xxx #安装插件npm unstall xxx #卸载插件 上述命令将贯穿于整个博客过程，不难，能动手尽量别复制粘贴 全程在博客目录下进行，离不开gitbash 建站问题及错误遇到问题不要慌，大胆猜测小心验证 站点配置文件12Sitekey: value#字段后必须空格 hexo d 发布时问题：ERROR Deployer not found: git 如果使用git方式进行部署需要需要安装对应的插件 解决：安装自动部署发布工具 npm install hexo-deployer-git --save 发布后页面404或无反应 github创建的仓库名必须为：username.github.io 配置文件：key: value必须空格 3.0后 类型需为git,仓库需为ssh形式: git@github.com:path/username.github.io.git 参考：知乎 FATAL Cannot read property ‘replace’ of null解决:站点配置文件 # URL url: http://yoursite.com url不能为空 发布时无反应，username.github.io 404定位：站点配置：发布地址为https://github.com/path/username.github.io.git 解决：\3.0版本以上使用如下配置：发布地址修改为 git@github.com:yourname/yourname.github.io.git git bash 提示如下表示发布成功 发表文章标题显示为无标题定位：手动新建的md文件 放于source文件夹且 文件遵守规则 解决：使用git bash 命令： hexo new&quot;xxx文件名&quot;此时 自动在source文件夹下生成 xxx文件名的md 文件，自带标题，修改此标题 即可 测试标题显示情况实验手动创建文章遵守规则 123456---title: 文章测试文件tags:category:--- 启动服务，验证：成功 已有md文件，手动添加title遵守规则成功 复现文章标题失败情景复现失败猜测：网页缓存或浏览器缓存导致，待验证 hexo g 生成静态网页时 类似错误参考 问题重点：Error: Unable to call __, which is undefined or falsey 定位：md文件出现不识别字符：__ 解决： 找到对应字符，转义或删除 404页面直接添加到站点失败参考知乎 使用 hexo new page&quot;404&quot;，编辑index.md文件即可 部署到GitHub后头像显示失败图片放于主题：\themes\next\source\images\路径，显示成功站点:\source\uploads\路径，显示失败 主题完整路径：\themes\next\source\images\avatar.jpg 主题配置：avatar: /images/avatar.jpg 参考 主题配置文件 关闭页面评论Next官网 index.md文件增加comments: false #关闭页面评论显示 文章插入代码块 使用 codeblock endcodeblock 标记swig模板代码,代码无法显示 使用tab 标记代码块，显示为非源码 改为``` 包裹代码 标记 可正常显示 参考知乎 代码包含 &#123;&#123; &#125;&#125;or &#123;&#37; &#37;&#125; 编译出错官方方案使用&#123;&#37; raw &#37;&#125; &#123;&#37; endraw &#37;&#125;包裹]]></content>
      <categories>
        <category>原创</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Git</tag>
        <tag>Hexo</tag>
        <tag>Node.js</tag>
        <tag>实战</tag>
        <tag>初级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio Gradle-Build 龟速解决方案]]></title>
    <url>%2Fgradle-build-solution.html</url>
    <content type="text"><![CDATA[前言： AndroidStudio 重度用户们，试问，谁没经历过Build乌龟爬一般的耗时煎熬？ 忍无可忍，无须再忍。 给你一个靠谱、真实有效解决方案，一招直达痛处 效果先看配置后：平均28s，这个跟机器配置，项目大小，修改内容也有关系 未配置的： 将近5分钟 ,同等条件！！ 相对来说，减少了不止一大半时间，感觉很爽有木有 实现gradle.proerties 文件org.gradle.daemon=true org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8 org.gradle.parallel=true org.gradle.configureondemand=true Android Studio setting:环境：studio 3.0,win7 64位 16G 参考： 奉上原文，感谢作者]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>解决方案</tag>
        <tag>Gradle</tag>
        <tag>Build</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用优化与开发流程]]></title>
    <url>%2Fapplication-optimization-and-development.html</url>
    <content type="text"><![CDATA[前言：日常开发 代码与资源的优化必不可避，无论是为了提高代码质量还是为了提高用户留存度吾日三省吾身，今天你优化了没真实项目开发优化经历，LeakCannary与Lint 带你飞 优化内存泄露最常见最严重 ：后果不限于 OutOfMemory 持有Activity 与Context引用，生命周期本该短于应用生命周期，该回收的没被回收掉，导致泄露检测手段：最方便leakcanary ，历史悠久的 MIT Handler泄露new Handler 替换为 静态内部类 将持有当前Activity或Context 对象实例化为WeakReference对象 onDestory 时：handler.removeAllMessageAndCallback(null) 高级方案：不可避免的Handler仍采用静态内部类，提供CallBack,独立于使用者,避免Activity与Context直接引用 更高级的方案：可以避免的Handler使用RxJava 单例泄露单例对象持有的Activity 使用WeakReference 、Context 使用ApplicationContext 去除不必要的Activity引用 泄露不止显式的Activity 与context,一旦定义其他对象，且该对象引用了Context或Activity ,却比应用生命周期短，也会发生泄露，比如单例里使用了RecyclerView 此时需要考虑使用WeakReference 持有该对象引用 这时，应该想想可否将其独立出来 Fragment 之间静态属性引用 泄露消灭静态属性 静态属性会一直持有当前Activity或Context引用 Fragment之间通讯可使用接口，Activity实现该接口， onAttach 将Activity转换为接口对象 Activity操作Fragmeng方式不变 高级方案：可使用MVVM ，ViewModel方式 Cursor 等游标、流的关闭数据库操作：增删改查的游标，文件、网络操作流用后close ListonDestory销毁List：clear WebViewonDestory销毁WebView ：removeJavaScript;removeAllView高级方案：多进程 避免原则尽可能保证持有的对象及时被回收，必须使用Activity的采用WeakReference,能使用ApplicationContext的不使用 当前Context其他对象生命周期短于应用的，一旦持有了Context或Activity都有可能发生泄露，尽可能采用WeakReference 代码优化优化的数据结构HashMap 替换为SparseArray 等 枚举、匿名内部类、反射等减少使用 布局，涉及过渡绘制等背景窗体背景，多余背景，减少过渡绘制有效手段 过渡绘制include标签（通常用于公共布局组件）、merge（有效减少层级，但会出现不可控因素，属性失效等问题）、viewsub 减少不必要的层级 控件优化比较突出的：ImageView 与TextView 呈上下左右关系时，优先考虑TextView增加drawable属性，即compoundDrawable 布局设置：drawableLeft ,drawableTop, drawableRight,drawableBoottom图片文字间距使用：drawablePadding 代码设置：setCompoundDrawablesRelativeWithIntrinsicBounds(left，top,right,bottoom) 内存、网络、电池BitMap的回收，应用不可见的监听，减少app被系统关闭的几率 安装包与第三方无用资源，大图，图片适配，减少不必要的图片，png替换为.9,简单图片代码实现优先 lib 文件 开发与测试架构业务、实现分离MVP或MVVM等viewmodel代码规则：命名，方法数，自解释 目的：便于维护 流程测试环节如：用例覆盖，情景覆盖，功能效果与产品需求匹配度等，数据抓取，可考虑以下方案增强 全员测试开发阶段由开发把控，确认主要流程功能完成后打包安排测试，主要为产品确认功能实现情况，及时发现问题，以免后期不断产生功能修改，耽误开发进度 测试阶段除测试外所有相关人员，包括但不限于：前后端开发、产品、项目负责人 上线前最后的问题发现修改阶段，也是最后的问题修改阶段，避免上线前后发生重大问题 测试次数问题修改完一批次之后统一回归，可分为第一轮至第三轮甚至四轮，根据测试及bug情况安排，除第一轮外后续皆主要为回归，最后一轮进行线上环境测试，确认功能与稳定性，正式上线前可考虑发布小范围用户安装包进行用户实际环境测试，俗称灰度 测试用例测试拿到需求之后可编写测试用例，此用例可指导其他人进行功能验证，减少测试人员压力 目的控制bug数量，减少测试费时，尽可能的发现隐藏的问题，避免上线后发生重大事故提升项目质量 数据监控抓取手法可使用Charles,Fiddler等 数据类问题可直接由bug测出人员定位，避免其他人浪费时间定位 版本分离bug分离上线后的bug确认是否为重大bug是否需要修改，一旦确认可下期修改，则可列为后期版本优先修改内容 api数据分离最基本的数据稳定性保持方法api上线时，安装包未必会及时被上传，此时线上环境已经发生变动，而用户所用仍为老版本，一旦数据不兼容，用户无法正常使用 api可根据app的versioncode与平台等多参数进行数据隔离 问题监测主要为稳定性服务 手段包括但不限于：真实用户实时崩溃日志：百度等 内嵌的日志收集上传功能 后台统计与收集 开发阶段的崩溃收集：崩溃截取显示上传功能 开发阶段 编写高质量代码 性能优化手段LeakCanary 内存泄露 findbug bug 、隐藏问题 removed unused resoures 剔除废弃资源 Lint 找出隐藏问题，优化代码，重点关注Performance 如泄露，Correctness,Security 内存泄露监测方法说是监测，是因为在程序运行过程中，当发生泄露，我们的金丝雀可以直接将泄露信息dump出来参考1:LeakCanary官网参考2:LeakCanary中文说明 Gradle配置： debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5.4&apos; releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no- op:1.5.4&apos; Application ： /** * 使用 RefWatcher 监控本该被回收的对象 * LeakCanary.install() 会返回一个预定义的 RefWatcher，同时也会启用一个 ActivityRefWatcher， * 用于自动监控调用 Activity.onDestroy() 之后泄露的 activity。 * @param context * @return */ public static RefWatcher getRefWatcher(Context context) { Application application = (Application) context.getApplicationContext(); return application.refWatcher; } private RefWatcher refWatcher; protected RefWatcher installLeakCanary() { return RefWatcher.DISABLED; } if (LeakCanary.isInAnalyzerProcess(this)) { return; } refWatcher = LeakCanary.install(this); Fragment/** * 使用 RefWatcher 监控 Fragment */ RefWatcher refWatcher = Application.getRefWatcher(getActivity()); refWatcher.watch(this); 详细说明请参考上面贴出的参考链接 Lint 代码资源检测方法参考 这个工具可以提前检测出内存泄露、无用资源、以及一些不规范代码等，需要我们重点关注的点前面以及上面的参考已经详细说明]]></content>
      <categories>
        <category>原创</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>内存泄露</tag>
        <tag>解决方案</tag>
        <tag>优化</tag>
        <tag>LeakCanery</tag>
        <tag>Lint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 基础命令]]></title>
    <url>%2Fgit-learning.html</url>
    <content type="text"><![CDATA[前言：跟随大神脚步，廖雪峰 Git 教程学好Git,早日掌握代码托管利器 环境与版本库环境安装windows版本 Git打包好的模拟环境及git: msysgit 验证开始菜单，Git–Git Bash 配置命令： git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 说明： git config –global 参数表示当前机器所有用户都是使用该配置 版本库进入版本库 ：cd e:/learngit 1.创建版本库（仓库）选择合适位置创建空目录，Windows环境要确保路径不包含中文： 进入目标盘符命令：cd e:/ 确认进入，查看文件命令：ls 创建仓库命令：mkdir &lt;repo-name&gt;cd &lt;repo-name&gt; pwd显示为：/路径/ 注：pwd显示当前目录路径 2.将空目录变成Git可以管理的仓库命令：git init提示：Initialized empty Git repository in /路径//.git/.git目录：Git用来跟踪管理版本库，勿动；默认隐藏， ls -ah查看路径 3.将文件添加提交到仓库，无提示即为成功注：文件放入仓库目录，否则Git无法找到命令： git add &lt;file&gt;作用：添加文件到仓库 命令： git commit -m &quot;infomation&quot;作用：将文件提交到仓库 注：-m后必须跟随本次提交的说明，否则将无法继续操作！！！！ 扩展： 1.add &lt;file&gt; 可反复使用，添加多个文件 commit可以一次提交很多文件如： git add file1.java git add file2.xml git add flie3.png …… git commit -m “add many files” 2.add.：提交当前工作区未被配置为忽略的所有文件到暂存区（更喜欢存储区这个称呼） 状态命令：git status 作用：时刻掌握仓库当期状态 diff信息命令：git diff 作用：查看difference,以unix通用diff格式显示 历史记录命令：git log 作用：查看提交历史，从最近到最远，可确定回退版本，会进入log界面 扩展：git log --pretty=oneline –pretty==oneline 单行显示重要信息，包含：commit-id ,commit information 版本号commit id HASH值 以16进制表示 版本回退命令：git reset --hard HEAD^ 作用：回退到上一个版本 注：HEAD指向当前版本 HEAD^上个版本 HEAD^^上两个版本，上100个版本 HEAD~100 命令： git reset --hard commit-id 作用：回退到指定版本： 注：id不需要写全，也不要太短，git会自动查找 命令：cat &lt;file&gt;作用：查看文件 查看命令历史命令： git reflog 作用：查看命令历史，可用于查看commit-id及HEAD版本， 用于版本回退 工作区与暂存区一些简单说明工作区包含隐藏目录.git ，是Git版本库 创建版本库时，Git默认创建第一个分支master，并包含暂存区stage git add &lt;file&gt;：添加文件，实际上是将文件修改添加到暂存区 git commit &lt;file&gt;：提交更改，实际上是把暂存区的所有内容提交到当前分支 Git 跟踪修改，若没有add添加到暂存区，就不会加入到commit 队列 版本比对命令：git diff HEAD --&lt;file&gt;作用：查看工作区和版本库里最新版本的区别 撤销修改命令：git checkout -- &lt;file&gt; 作用：撤销工作区修改，让文件回到最近一次git commit 或git add时的状态，”–”很重要，没有则为切换分支；已添加到缓存区的无法直接撤销，需先重置缓存区，配合git reset使用 重置命令：git reset 作用：既可以回退版本，也可以把暂存区的修改，非删除的回退到工作区 命令：git reset HEAD &lt;file&gt;作用：撤换暂存区的修改unstage，重新放回工作区 注： 1.直接丢弃工作区，非缓存区的修改checkout -- &lt;file&gt; 2.修改了工作区内容，且添加进缓存区，想丢弃修改，先git reset HEAD &lt;file&gt;或git rest 再git checkout -- &lt;file&gt; 3.工作区修改已提交版本库，恢复只能通过版本回退！ 删除文件 rm命令：git rm &lt;file&gt; 作用：从版本库删除文件 注：删除后需commit提交，否则工作区与版本库不一致 命令： git checkout -- &lt;file&gt; 作用：工作区删除但未提交，可以用版本库版本替换工作区版本，无论工作区是修改还是删除；若已提交，则无法恢复,除非回退版本 远程仓库1.使用免费开放的GitHub 2.搭建Linux服务器 GitHub检查用户主目录下，是否有.ssh目录id_rsa和id_rsa.pub两个文件 1.创建SSH Keywindows下打开Git Bash 命令：ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 默认值即可，无需设置密码 2.添加用户到远程仓库登陆GitHub，“Account settings”，“SSH Keys”页： “Add SSH Key”，任意Title，Key文本框里粘贴id_rsa.pub文件的内容SSH Key,GitHub需识别出推送的提交确实是本人推送，而非他人冒充。 Git支持SSH协议 GitHub允许添加多个key 1.添加远程仓库GitHub： Create a new repo按钮创建一个新的仓库 Repository name填入仓库名repo-name，其他默认，“Create repository 2.关联一个远程库命令：git remote add origin git@server-name:path/&lt;repo-name&gt;.git 如：git remote add origin git@github.com:GitHub帐户名/repo-name.git 添加后，远程库的名字就是 origin,此为Git默认名称，可以更改 3.关联后推送master分支所有内容命令：git push -u origin &lt;branch-name&gt; 注：-u 关联本地库内分支与远程库内分支 命令：git push origin branch-name 每次提交本地版本库后，只要有必要，推送最新修改 也可使用： git push直接推送到当前分支关联的远程分支，未关联时使用此命令会提示 fatal: The current branch &lt;branch&gt; has no upstream branch. To push the current branch and set the remote as upstream, use git push --set-upstream origin &lt;branch&gt; 4.推送并关联远程分支：git push --set-upstream origin &lt;branch&gt; 此后便可直接使用git push完成提交 注： 第一次使用Git的clone或push命令连接GitHub时，会得到一个警告： The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established. RSA key fingerprint is xx.xx.xx.xx.xx. Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 克隆命令：git clone git@github.com: 路径/&lt;repo-name&gt;.git 作用：从远程库克隆git clone 注： 必须知道仓库的地址 git支持多种协议 包括https 通过ssh支持原生git协议速度最快 分支管理分支创建及切换命令：git checkout -b &lt;branch-name&gt;作用： 创建并切换分支 开发分支 假设为：dev分支如：git checkout -b dev 相当于： git branch git checkout 命令：git branch 作用： 列出所有分支,当前分支前会标有星号 命令：git checkout &lt;branch-name&gt; 作用： 切换回当前分支 命令：git merge &lt;branch-name&gt; 作用： 合并指定分支到当前分支,直接将当前分支指向指定分支的提交内容，可理解为快速模式 git merge --no-ff -m&quot;infomation&quot; &lt;branch&gt; 作用：非快速模式，可保留分支信息 命令：git branch -d &lt;branch-name&gt; 作用： 删除分支 解决冲突多分支同时修改相同文件，合并时可能会出现冲突提示： Automatic merge failed; fix conflicts and then commit the result. 此时需手动解决冲突，再add ，commit 题外话：android studio中：右键冲突文件—&gt;解决冲突—&gt;apply 查看分支合并图命令：git log --grahp 作用：显示多行分支信息 命令：git log --graph --pretty=oneline --abbrev-commit作用：单行显示分支信息 分支管理策略git merge &lt;branch&gt; 快速模式合并分支，会丢失分支信息 git merge --no-ff -m&quot;infomation&quot; &lt;branch&gt;普通模式，禁用Fast forward 模式 git log日志查看：普通模式下，合并后可以看到曾经做过合并，有历史分支信息； 分支管理策略master分支应该是最稳定的，仅用来发布新版本，平时不能操作，在dev分支开发，发布时再合并到master分支 说明： master分支是主分支，需要时刻与远程同步 dev 是开发分支，团队所有成员都在上面工作，也需要与远程同步 bug分支 只用于本地修复bug，没必要推送到远程 feature分支是否推送到远程，取决于是否和小伙伴合作开发 克隆远程库默认只可见master分支 本地新建的分支如果不推送到远程，对其他人是不可见的。 本地工作分支提交修改建立本地分支与远程分支链接本地创建和 远程库分支 对应的分支，名称最好一致：远程分支：origin/branch-namegit checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt; 建立本地与远程分支的连接git branch --set-upstream-to branch-name origin/branch-name 从远程仓库克隆时，Git自动把本地master分支和远程master分支对应，远程仓库默认名称是origin，以创建为准 强行删除分支：git branch -D &lt;branch-name&gt; 本地未完成的修改临时存储列出已有存储git stash list 临时存储工作现场，保存未完成的工作，确保工作区干净，以便切分支，完成其他任务 git stash 恢复工作现场 git stash apply 提交恢复 git stash drop删除stash内容 批量删除可以使用git stash clear git stash pop 恢复的同时删除stash内容 当有多次stash时： 可先 git stash list查看id，然后恢复指定stash git stash apply &lt;stash-id&gt; 如：git stash apply stash@{0} 查看远程仓库信息git remote 显示更详细信息git remote -v 注：若没有推送权限，将看不到push地址 远程修改抓取推送本地修改之前必须要先做的 抓取分支git pull注：建立本地与远程对应分支连接后再拉取，无需任何分支名称。 推送分支指定本地分支推送到远程库git push origin 如：dev分支 git push origin dev注：若推送失败，先用git pull抓取远程的新提交 git push注：从指定远程库分支抓取最新提交，若有冲突，先手动解决冲突，再push 多人协作的工作模式通常是这样： 试图用 git push origin bracn-name 推送自己的修改 如果推送失败，先用 git pull试图合并 如果合并有冲突，则解决冲突，并在本地提交 没有或解决掉冲突后，再用git push origin branch-name推送就可以成功 标签管理tag与commit-id绑定，便于查找 查看标签git tag查看所有标签 打新标签 切换到需要打标签的分支 先查看分支信息git branch 切换指定分支git checkout &lt;branch&gt; git tag 新标签默认打在HEAD,既最新提交的commit上 指定提交记录打标签: 查找历史提交commit idgit log --pretty=oneline --abbrev-commit 再打标签git tag &lt;tagname&gt; commit-id 标签默认按字母排序，不按时间 查看标签信息git show &lt;tagname&gt; 创建带有说明的标签-a指定标签名，-m指定说明文字git tag -a &lt;tagname&gt; -m &quot;infomation&quot; commit id 用私钥签名标签 -sgit tag -s &lt;tagname&gt; -m &quot;infomation&quot; commit id 说明： 签名采用PGP，必须先安装gpg(GnuPG)，若没找多或没有gpg密钥对，就会报错gpg: signing failed: secret key not availableerror: gpg failed to sign the dataerror: unable to sign the tag如果报错，请参考GnuPG帮助文档配置Key。git show 可以看到GPG签名信息 删除标签git tag -d 将标签推送到远程git push origin 一次性推送全部尚未推送到远程的本地标签git push origin –tags 删除远程标签1.先删除本地 git tag -d 2.从远程删除,push命令 git push origin :refs/tags/ 3.检查远程删除结果，登录GitHub查看 Git 配置自定义Git让Git显示颜色 git config –global color.ui true 忽略特殊文件1.编写.gitignore在Git工作区根目录创建特殊的.gitignore文件，添加要忽略的文件名 2..gitignore 文件要放入版本库，并且可以对.gitignore做版本管理检验.gitignore的标准是git status命令是不是说working directory clean 检查规则是否有误，是否忽略了指定具体文件： git check-ignore -v 添加被.gitignore忽略的文件到版本库，强制性 git add -f 忽略文件的原则是： 1. 忽略操作系统自动生成的文件，比如缩略图等； 2. 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 3. 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件 命令别名git config --global alias. 如 ：st表示status git config –global alias.st status co表示checkout ci 表示commit br 表示branch 撤销更改别名配置：unstage原命令： git reset HEAD file git config –global alias.unstage ‘rest HEAD’ 更改后：git unstage &lt;file&gt; 显示最后一次提交的信息 git lastgit config --global alias.last &apos;log -1&apos; 更改后：git last 配置loggit config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; 更改后：git lg 注：–global针对当前用户起作用，不加只对当前仓库起作用每个仓库的配置文件位置：.git/config 查看：cat .git/config配置的别名在[alias]后 当前用户的Git配置文件在用户主目录下的一个隐藏文件.gitconfig查看：cat .gitconfig 使用GitHubGitHub 可以任意Fork开源仓库 自由拥有Fork后的自己帐号下的仓库的读写权限 自由从自己帐号下clone仓库才能推送修改 克隆如git clone git@github.com: michaelliao/bookstrap.git 可以推送pull request 给官方仓库贡献代码,官方决定是否接受 删除已有的GitHub远程库 git remote rm origin 关联远程库git remote add origin git@gitee.com:path/&lt;name&gt;.git 码云国内Git 托管服务 gitee.com 同时关联多个远程库 git的远程库默认名称是origin ,多个远程库需要不同的名称标识 使用已关联了GitHub远程库的情况下： 1.先删除已关联的名为origin的远程库 git remote rm origin 2.关联GitHub远程库 git remote add github git@github.com:路径/&lt;name&gt;.git 3.关联码云远程库 git remote add gitee git@gitee.com:路径/&lt;name&gt;.git 此时查看远程库信息，可以看到两个远程库 git remote -v 推送到GitHub git push github master 推送到码云 git push gitee master 搭建Git服务器使用Linux机器。推荐Ubuntu 或Debian 假设有sudo权限的用户帐号 1.安装git sudo apt-get install git 2.创建git用户，运行git服务 sudo adduser git 3.创建证书登录收集所有需要登录的用户的公钥，.id_ras.pub文件，导入到/home/git/.ssh/authorized_keys文件，一行一个 4.初始化Git仓库，选定一个目录作为Git仓库，假设为/srv/sample.git在/srv目录下输入 sudo git init –bare sample.git会创建一个裸仓库，没有工作区，通常以.git结尾，将owner改为git sudo chown -R git:git sample.git 5.禁用shell登录，出于安全考虑，git用户不允许登录shell,通过编辑/ect/passwd文件完成​ git:x:1001:1001:,,,:/home/git:/bin/bash改为 git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell git用户可以正常通过ssh使用git，因为我们为git用户指定的git-shell每次一登录就自动退出 克隆远程仓库 git clone git@server:/srv/sample.git * 搭建Git服务器非常简单，通常10分钟即可完成； * 要方便管理公钥，用Gitosis； * 要像SVN那样变态地控制权限，用Gitolite。 扩展：Git 与Android studio 的关联日常工作中可以通过studio的命令行来操作，减少窗口切换，省时省力 安装完git后，将git路径添加进studio：studio —setting—Version Control—Git—&gt;Test之后显示Successfully表明成功Terminal窗口内测试一下：输入git 搞定]]></content>
      <categories>
        <category>原创</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>基础</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令及一些问题 整理]]></title>
    <url>%2Fgit-skill.html</url>
    <content type="text"><![CDATA[廖雪峰Git教程基于学习Git过程进行总结，多思考多总结才能上天 git 常用命令本地仓库普通操作创建版本库git init 添加文件到缓存区git add file 添加到仓库git commit -m &quot;commint describtion&quot; 撤销修改或清除缓存区git reset /git reset HEAD file 丢弃或撤销修改git checkout -- file 删除git rm file相当于git rm后git add 撤销删除操作git resetgit checkout --file 查看指定文件git cat file 比对工作区与版本库git diff 查看日志 git log 操作历史git reflog 版本回退git reset --hard commit-id 或 git reset --hard HEAD-id相当于指定当前HEAD到指定版本 创建并指向分支git checkout -b &lt;branch&gt; 切换分支git checkout &lt;branch&gt; 查看分支信息git branch详细信息 git branch -v 合并指定分支到当前分支git merge &lt;branch&gt; 普通模式合并，保留分支信息git merge --no-ff -m &quot;&quot; &lt;branch&gt; 此信息会在远程显示 删除分支git branch -d &lt;branch&gt; 临时保存工作区现场git stash 列出工作区现场git list 删除现场并恢复工作区git stash pop 添加当前工作区全部文件到缓存区git add . 测试连接ssh -T git@github.com 远程库与本地库相关添加远程版本库git remote add origin git@github.com:路径/版本库.git 克隆远程分支库git clone git@server:path/repo.git 本地建立远程库对应分支git checkout -b branch origin/branch 从远程库拉取最新提交git pull 关联并推送本地版本库到远程库git push -u origin master 本地分支推送到远程库git push 查看远程仓库状态git remote show origingit remote -v 本地分支与远程分支比对git diff &lt;branch&gt; origin/&lt;branch&gt; 强制远程库覆盖本地git fetch --allgit reset --hard origin/mastergit pull 更新远程信息git remote update 追踪远程分支git fetch origin branch-name 建立本地与远程分支的连接git branch --set-upstream-to &lt;branch&gt; origin/&lt;branch&gt; 克隆指定分支git clone -b &lt;branch&gt; git@server-name:path/&lt;repo-name&gt;.git 合并冲突手动解决冲突之后 冲突文件–&gt;git-&gt;Resolve Conflicts 实战问题及解决方式本地相关commit 后无提交说明遇到的问题：Vim: Caught deadly signal SEGV,无法继续操作git?只能重启git窗口？ 退出log界面：q键退出 删除部分log?git reset –hard commit-id： HEAD指向commit-id版本，log只显示当前HEAD版本 ,回退全部后仍可显示全部log 删除全部log?待研究查看帮助git --help 指定命令帮助 git log -help git reset --hard HEAD-id：回退到指定HEAD版本，id可通过git reflog查看 版本回退：git reset HEAD^ 无–hard时：Unstaged changes after reset: M &lt;file&gt;; 有–hard时：完整命令： git reset --hard HEAD^HEAD is now at &lt;commit-id&gt; 结果HEAD都指向指定版本 未commit的：checkout – 提示文件匹配不到，需reset 或rest HEAD 清除缓存区之后才能撤销，-f强制删除 无法撤销 已commit的：reset后checkout也无法撤销，想撤销只能reset –hard commit-id或reset –hard HEAD回退到提交删除之前，无法回退指定文件 添加远程仓库时提示：fatal: remote origin already exists. 进入vi编辑器命令：vi .git/config删除remote “origin” 完成后退出vi编辑器: ESC后 shift+zz保存 退出 远程库与本地库操作相关版本库内文件，同一路径下的多个分支共享，分支提交，合并到主线 远程库默认名称根据我们初次连接远程库时创建的为准 git pull 提示there is no tracking information for the current branch说明本地分支和远程分支的连接关系没有创建 git pull提示error: The following untracked working tree files would be overwritten by merge:..... Please move or remove them before you can merge. Aborting 处理： git clean -d -fx &quot;&quot;其中x —–删除忽略文件已经对git来说不识别的文件d —–删除未被添加到git的路径中的文件f —–强制运行 本地与远程操作流程进入指定目录后若无仓库时初始化仓库关联远程仓库:git remote add origin git@server-name:path/&lt;repo-name&gt;.git查看远程仓库信息：git remote -v 两种情况：未clone过远程分支时：git remote show origin git remote update git pull 以上三个命令提示： GitLab: The project you were looking for could not be found. fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. checkout -b &lt;branch&gt; &lt;origin&gt;/&lt;branch&gt;时： 提示：fatal: &#39;origin/branch&#39; is not a commit and a branch &#39;branch&#39; cannot be created from it checkout &lt;branch&gt; &lt;origin&gt;/&lt;branch&gt;时提示：error: pathspec &#39;branch&#39; did not match any file(s) known to git. error: pathspec &#39;origin/branch&#39; did not match any file(s) known to git. 此时只能克隆git clone git@server-name:path/&lt;repo-name&gt;.git 获取仓库再操作 待研究验证 推送代码出现错误123$ git push -u remote mastererror: src refspec master does not match any.error: failed to push some refs to &apos;git@git.coding.net:username/repo.git&apos; 解决：提交本地代码，重新推送单仓库指向：1git push -u coding master 已克隆过远程分支时：已建立本地仓库与远程仓库对应连接，默认为master分支，需要切换到已clone的仓库代码路径，继续操作 git remote show origin 提示 trackedgit remote updategit pull 无最新提交提示already up-to-dategit fetch以上命令均可正常操作 后续操作建立并切换到与远程库对应本地分支git checkout -b branch origin/branch，变更已clone过的master分支代码为指定分支代码 git checkout master 切换到master分支，代码重下载 分支切换过程工作区代码会跟随分支变动 git status 查看仓库状态，未修改工作区情况下仓库状态不变 working tree clean 追踪远程库git fetch origin branch拉取最新提交git pull origin branch指定分支或git pull默认当前对应分支建立连接git branch --set-upstream-to &lt;branch&gt; origin/&lt;branch&gt; 问题：遇到过 git pull 及git remote update 不拉取提示new 且未追踪，待复现 注意：实际开发中需要切换分支之前需commit工作区到本地分支仓库，提交之后再切换分支，仓库代码将会有所区别 git stash临时保存工作区后，需记住stash id，再切换分支操作，切回远分支后通过git stash pop或stash apply &lt;stashid&gt;恢复原工作区 谨记：本地修改分支：用于本地修改 远程同步分支：用于pull及push；本地修改分支合并到该分支，再push 切换分支前提交或临时保存本地修改分支修改内容到本地仓库，以便切回该分支继续修改 日常git 代码操作流程本地仓库已与远程仓库关联后：查看远程仓库信息 git remote show origin追踪最新提交git fetch origin branch拉取最新提交 git pull 本地仓库未与远程关联时：关联本地仓库到远程仓库，clone远程分支，git fetch追踪，git pull拉取git push 提示：fatal: The upstream branch of your current branch does not matchthe name of your current branch. To push to the upstream branchon the remote, use git push origin HEAD:&lt;branch&gt;To push to the branch of the same name on the remote, use git push origin &lt;branch&gt; 完整提交流程git stash保存本地工作区 git checkout &lt;远程branch&gt;切换到远程分支 git pull拉取远程提交 git checkout &lt;本地branch&gt;切回本地 git merge --no-ff -m &quot;&quot; &lt;远程branch&gt;远程分支合并到本地，解决冲突 git checkout &lt;远程branch&gt; git merge --no-ff -m &quot;&quot; &lt;本地branch&gt;本地分支合并到远程 git push origin HEAD:&lt;branch&gt;或git push]]></content>
      <categories>
        <category>原创</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>解决方案</tag>
        <tag>Git</tag>
        <tag>总结</tag>
        <tag>技能</tag>
      </tags>
  </entry>
</search>
